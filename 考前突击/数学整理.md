# Catalan数

## 弦（第十七届同济大学校赛）

### 题意

​	给定一个圆，圆上有2N个互不重叠的点。每次操作随机选择两个先前未选择过的点连一条弦，共连成N条弦，求所有弦不交的概率。

​	$1\leq N\leq 10^7$

### 思路

​	合法方案数$f(n)=\sum f(i)*f(n-i-1)$，即Catalan数。

​	总方案数为$\frac{C(2n, 2) * C(2n – 2, 2)* ... *C(2, 2)}{n!}$。

​	两者相除即为答案。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 2e7+10;
const int mod = 1e9+7;
int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
int mul(int a,int b){return 1LL*a*b%mod;}
int sub(int a,int b){return a<b? a-b+mod: a-b;}
int qpow(int a,int b){
    int ret = 1;
    for( ; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
int jc[N], rjc[N];
void init(){
    jc[0] = 1;
    for(int i = 1; i<N; i++) jc[i] = mul(jc[i-1],i);
    rjc[N-1] = qpow(jc[N-1],mod-2);
    for(int i = N-2; i>=0; --i) rjc[i] = mul(rjc[i+1],i+1);
}
int C(int n,int m){
    return mul(jc[n],mul(rjc[m],rjc[n-m]));
}
int main(){
    init();
    int n; cin>>n;
    int fz = sub(C(2*n,n),C(2*n,n-1));
    int fm = qpow(jc[n],mod-2);
    for(int i = 1; i<=n; i++){
        fm = mul(fm, C(2*i,2));
    }
    cout<<mul(fz,qpow(fm,mod-2))<<endl;
}
```

----

# 递推

## 斐波那契和（第十七届同济大学校赛）

### 题意

​	$Fib(i)$表示斐波那契函数，

​	给定正整数$n$和$k$，求： $\sum_{i=1}^ni^kFib$(i)

​	结果对998,244,353取余。 

​	$1\leq n\leq 10^{18}, 1\leq k\leq 100$

### 思路

#### 方法1:

​	如果一个数列，其能够通过线性递推而来：$F_n=\sum_{i=1}^kF_{n-i}a_i$

​	（例如使用矩阵快速幂优化的 DP 大概都可以丢进去）

​	则使用 BM 即可得到任意 N 项的数列元素。

#### 方法2：

​	考虑$F_k'(n)=\sum_{i=1}^n(n-i)^kFib(i)$，这个比$F_k(n)=\sum_{i=1}^ni^kFib(i)$好求一些。

​	做一次差分，可以得到：

​		![递推](/Users/baoliang/Downloads/ACM/错题整理/pic/递推.png)

​	可以用矩阵快速幂求出所有$F_j'(n)$。

​		对一个向量，维护$Fib(n),Fib(n-1)$以及所有$F'_j(n)$，

​		对于$F'_0(n+1)$，用$F_0'(n+1)=F_0'(n)+F_0'(n-1)$计算，其他用上述公式。

​		向量共k+3维。

​	得到$F'_j(n)$之后，我们可以展开得到关于$F(n)$的表达式：

​	$F_k'(n)=\sum_{j=0}^kn^{k-j}(-1)^jF_j(n)$，

​	得到，$(-1)^kF_k(n)=F_k'(n)-\sum_{j=0}^{k-1}n^{k-j}(-1)^jF_j(n)$。

​	复杂度$O(k^3log(n))$

### 代码

#### 方法1：

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define pii pair<int, int>
#define pss pair<string, string>
#define fir first
#define sec second

const int mod = 998244353;

// BM 模版
namespace linear_seq {
    #define rep(i,a,n) for (int i=a;i<n;i++)
    #define SZ(x) ((int)(x).size())
    typedef vector<int> VI;
    const int N=10010;
    ll res[N],base[N],_c[N],_md[N];
    VI Md;
    ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
    void mul(ll *a,ll *b,int k) {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (int i=k+k-1;i>=k;i--) if (_c[i])
                rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    int solve(ll n,VI a,VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+...
        ll ans=0,pnt=0;
        int k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (int p=pnt;p>=0;p--) {
            mul(res,res,k);
            if ((n>>p)&1) {
                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s) {
        VI C(1,1),B(1,1);
        int L=0,m=1,b=1;
        rep(n,0,SZ(s)) {
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if (d==0) ++m;
            else if (2*L<=n) {
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            } else {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a,ll n) {
        VI c = BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};

const int N = 1e5+10;
int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
int f[N];
vector<int> vec;
int main(){
    ll n; int k; cin>>n>>k;
    f[0] = 0, f[1] = 1;
    int sum = mul(f[1],qpow(1,k));
    vec.pb(sum);
    for(int i = 2; i<N; i++){
        f[i] = add(f[i-1], f[i-2]);
        sum = add(sum, mul(f[i],qpow(i,k)));
        vec.pb(sum);
    }
    cout<<linear_seq::gao(vec,n-1)<<endl;
}
```

----

## Beautiful Mirrors（cf-604-div1-C, hard-version）

### 题意

​	$n$个点，从$1$开始，点$i$有$p_i$概率进入下一个点，$1-p_i$概率回到最近的复活点，$1$为永久复活点。

​	$q$次询问，每次添加或删除一个复活点，回答最后走出$n$个点的期望步数。

​	$n\le2\times 10^5$

### 思路

​	将复活点视为划分区间的左边界，统计每个区间。

​	考虑$[1,n]$的区间，设$E_i$为$i$走到$n+1$的期望步数，有

​	$E_i=p_i\times (1+E_{i+1})+(1-p_i)\times(1+E_1)$

​	不停将$E_{i+1}$代入$E_i$，通过规律得到通项公式：

​	$E_1=\frac{1}{p_n}+\frac{1}{p_np_{n-1}}+...+\frac{1}{p_np_{n-1}...p_1}$

​	推广到$[l.r]$区间，设$E[l, r]$表示从$l$经过区间$[l, r]$到达$r$的期望步数：

​	$E_{[l,r]}=\frac{1}{p_r}+\frac{1}{p_rp_{r-1}}+...+\frac{1}{p_{r}p_{r-1}...p_1}$

​	设$S(i) = p_1p_2…p_i$，则有：

​	$E_{[l, r]} = \frac{S(l-1) +…+ S(r-1)}{S(r)}$

​	对S维护前缀和，就能每次O(1)的处理每个区间。每次询问用set维护区间即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 1e6+10;
const int mod = 998244353;
inline int mul(int a,int b){return 1LL*a*b%mod;}
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b&1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
inline int rev(int x){ return qpow(x,mod-2);}
int p[maxn], sum[maxn];
set<int> st;
int ans = 0;
int cal(int l,int r){
    return mul(sub(sum[r],sum[l-1]),rev(p[r]));
}
void solve(int x){
    auto it = st.find(x);
    if(it!=st.end()){
        int l1 = *(--st.find(x)), l2 = *(++st.find(x));
        st.erase(x);
        ans = sub(ans,add(cal(l1,x-1),cal(x,l2-1)));
        ans = add(ans,cal(l1,l2-1));
    } else {
        st.insert(x);
        int l1 = *(--st.find(x)), l2 = *(++st.find(x));
        ans = sub(ans,cal(l1,l2-1));
        ans = add(ans,add(cal(l1,x-1),cal(x,l2-1)));
    }
}
int main(){
    int n, q; cin>>n>>q;
    p[0] = 1, sum[0] = 0;
    int fm = rev(100);
    for(int i = 1; i<=n; i++){
        int x; scanf("%d",&x);
        sum[i] = add(sum[i-1],p[i-1]);
        p[i] = mul(p[i-1],mul(x,fm));
 
    }
    st.insert(1), st.insert(n+1);
    ans = cal(1,n);
    while(q--){
        int x; scanf("%d",&x);
        solve(x);
        printf("%d\n",ans);
    }
}

```

---

# 第二类斯特林数

## 基础知识

​	第二类斯特林数$S(n,m)$表示的是把$n$个**不同**的小球放在$m$个**相同**的盒子里方案数。

​	一般有两种解法：

### 递推

​	$S(n,m)=S(n−1,m−1)+mS(n−1,m)$	

​	讨论第一个球是否单独在一个盒子里面。

​	如果不独占一盒，那么把这个球放进任一个盒子，这个盒子就相当于与其他的盒子不同，那么在乘答案的时候就要多乘一个m.

###容斥原理

​	$S(n,m)=\frac{1}{m!}\sum_{k=0}^{m}(-1)^kC(m,k)(m-k)^n$

​	即枚举空盒的个数，剩下的随意放置，由于盒子是相同的最后要除以$m!$

​	（不除以$m!$就是不同球不同盒）

---

## Placing Rooks（cf-Edu86 E）

### 题意 

​	在一个$n∗n$的国际象棋棋盘中，有$n$个车，问这$n$个车在棋盘中有多少种放置的方法可以满足以下条件：

​	每一个空格子都受到攻击；

​	有刚好$k$对车相互攻击。

​	$n\leq 2e5$

### 思路

​	要有刚好$k$对车相互攻击必须有严格的$n−k$列有车子。

​	我们从$n$列中任意选择$n-k$列让其有车，一共有$C(n,n-k)$种方案。

​	然后就是不同球不同盒问题。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 2e5+10;
const int mod = 998244353;
int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
int mul(int a,int b){return 1LL*a*b%mod;}
int sub(int a,int b){return a<b? a-b+mod: a-b;}
int jc[N], rjc[N];
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b&1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
void init(){
    jc[0] = 1;
    for(int i = 1; i<N; i++) jc[i] = mul(jc[i-1], i);
    rjc[N-1] = qpow(jc[N-1],mod-2);
    for(int i = N-2; i>=0; --i) rjc[i] = mul(rjc[i+1],i+1);
}
int C(int n,int m){
    return mul(jc[n], mul(rjc[m], rjc[n-m]));
}
int main(){
    init();
    int n; ll k;
    cin>>n>>k;
    if(k >= n){
        puts("0");
    } else {
        int m = n-k, ans = 0;
        for(int i = 0; i<=m; i++){
            if(i & 1) ans = sub(ans, mul(C(m,i), qpow(m-i,n)));
            else ans = add(ans, mul(C(m,i),qpow(m-i,n)));
        }
        ans = mul(ans, C(n,m));
        if(k == 0) cout<<ans<<endl;
        else cout<<mul(ans, 2)<<endl;
    }

}
```

------

# 概率/期望

-----

## Set1（2020hdu多校-5）

### 题意

​	给定一个 1～n（n为奇数） 的集合S，每次删除当前集合中最小的元素，再随机删掉1个元素，直到 |S|=1，求每个元素最后被留下来的概率。

​	T∈[1,40]，∑n∈[1,5×106]

### 思路

​	考虑元素i被留下来的方案数，前面有 $i-1$个元素，后面有 $n-i$个元素。当且仅当$n-i\le i-1$时，i才可以被留下。

​	i被留下来的情况，一定是后面所有的元素( n-i个)，全部被前面 个元素中的某个 1对 1的选择 (使用第二种操作 )，那么对于后n-i个元素，它们被选择的方案数是$$\left( \begin{matrix} i-1\\n-1 \end{matrix} \right) \times (n-1)!$$。

​	然后剩下的$(i-1)-(n-i)=(2\times i-n-1)$个元素两两删除。

​	那么$i$被留下来的方案数：

​	$cnt[i]=\left( \begin{matrix} i-1\\n-1 \end{matrix} \right) \times (n-1)!\times \left (\begin{matrix}2\times i-n-1\\2,2,2,...,2\end{matrix}\right)$

​	$=\left( \begin{matrix} i-1\\n-1 \end{matrix} \right) \times (n-1)!\times \frac{(2\times i-n-1)!}{2^{(2\times i-n-1)/2}((2\times i-n-1)/2)!}$	

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int mod = 998244353;
const int N = 5e6+10;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){
    int ret = 1;
    for( ;b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
int jc[N], rjc[N], r2[N], cnt[N];
void init(){
    jc[0] = 1;
    for(int i = 1; i<N; i++){
        jc[i] = mul(jc[i-1], i);
    }
    rjc[N-1] = qpow(jc[N-1], mod-2);
    for(int i = N-2; i>=0; --i){
        rjc[i] = mul(rjc[i+1], i+1);
    }
    int rev2 = qpow(2, mod-2);
    r2[0] = 1;
    for(int i = 1; i<N; i++){
        r2[i] = mul(r2[i-1], rev2);
    }
}
int C(int n,int m){
    return mul(jc[n], mul(rjc[n-m], rjc[m]));
}
int main(){
    init();
    int T; cin>>T;
    while(T--){
        int n; scanf("%d",&n);
        int m = n/2, sum = 0;
        for(int i = 1; i<=n; i++) {
            if (i <= m) cnt[i] = 0;
            else {
                int t = 2 * i - n - 1;
                int ans = mul(C(i - 1, n - i), jc[n - i]);
                ans = mul(ans, mul(mul(jc[t], r2[t / 2]), rjc[t/2]));
                cnt[i] = ans;
                sum = add(sum, cnt[i]);
            }
        }
        int rsum = qpow(sum, mod-2);
        for(int i = 1; i<=n; i++) {
            printf("%d%c",mul(cnt[i],rsum)," \n"[i==n]);
        }
    }
}
```

-----

## Set2（2020hdu多校-5）

### 题意

​	给定一个 1～n 的集合S，每次删除当前集合中最小的元素，再顺序地随机删掉k个元素，直到 $|S|\le k$，求每个元素最后被留下来的概率。	

​	$T∈[1,40], n∈[1,5000],k∈[1,5000]$

### 思路	

### 代码

-----

### Borrow（2020hdu多校-6）

### 题意

​	有三个整数x,y,z，每次把最大的数（如果有多个随机选）-1，再随机挑一个非最大的数+1，求这样操作直到三个数相同的期望步数。

​	$x+y+z\le 10^6,\sum x+y+z\le 3\times 10^6$

### 思路

​	首先，有解的前提是$x+y+z\equiv 0(mod\ 3)$。设$m=\frac{x+y+z}{3}$。

​	不妨设$x\ge y\ge z$，如果有解的话$x$必然会到达$m$，也即$x$必然会将$x-m$分配给$y,z$。由于随机挑选，所以分配给$y,z$的概率可以直接得出。注意到给钱的顺序与最后的结果无关，可以先让$x$直接给出 $x−m$ 元钱（相当于$x-m$步$x$的确定分配，先挪用到前面），此时会得到 $m+a,m,m−a$ 的形式，其中 $a$ 是一个不确定且可以枚举的数，这和$0,c,2c$ 是本质相同的。

​	设 $f(x)$ 表示 $0,x,2x$ 状态下的期望步数， $2x$ 的人必须给出 $x$，可能的方案有$2^x$种，其中能够使得状态变为 $0,i,2i$的有$C(x,i)$中（即将i给x，将x-i给0），所以有$f(x)=x+\sum_{i=0}^x\frac{C_x^i}{2^x}f(i)$。

​	打表猜测$f(x)=2x$，接下来我们证明$f(x)=2x$：

​	基础：

​		当$x=0$时，$f(x)=0$满足。

​	归纳：

​		设$0,1,...,x$满足条件，则对于$x+1$：

​		$f(x+1)$ =$x+1+\sum_{i=0}^{x+1}\frac{C_{x+1}^i}{2^{x+1}}f(i)$

​						   =$x+1+\frac{1}{2^x}\sum_{i=0}^{x+1}iC_{x+1}^i$

​						   =$x+1+\frac{1}{2^x}\sum_{i=1}^{x+1}iC_{x+1}^i$			

​						   =$x+1+\frac{1}{2^x}\sum_{i=1}^{x+1}i\frac{(x+1)!}{i!(x+1-i)!}$	

​						   =$x+1+\frac{x+1}{2^x}\sum_{i=1}^{x+1}\frac{x!}{(i-1)!(x+1-i)!}$

​						   =$x+1+\frac{x+1}{2^x}\sum_{i=1}^{x+1}C_{x}^{i-1}$	

​						   =$x+1+\frac{x+1}{2^x}\sum_{i=0}^{x}C_{x}^{i}$	

​						   =$x+1+x+1$	

​						   =$2(x+1)$	

​		得证。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define pii pair<int, int>
#define pll pair<ll, ll>
#define pss pair<string, string>
#define pdd pair<double, double>
#define fir first
#define sec second
const int N = 1e6+10;
const int mod = 998244353;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
inline int inv(int x){
    return qpow(x, mod-2);
}
int fac[N], ifac[N], p2[N];
inline int C(int n,int m){
    return mul(fac[n], mul(ifac[n-m], ifac[m]));
}
void init(){
    p2[0] = 1;
    for(int i = 1; i<N; i++) p2[i] = mul(p2[i-1], 2);
    fac[0] = 1;
    for(int i = 1; i<N; i++) fac[i] = mul(fac[i-1], i);
    ifac[N-1] = inv(fac[N-1]);
    for(int i = N-2; i>=0; --i) ifac[i] = mul(ifac[i+1], i+1);
}
int cal(int x,int y,int z){
    if((x+y+z) % 3) return -1;
    int m = (x+y+z)/3;
    int ans = 0;
    for(int i = 0; i<=x-m; i++){
        int cur = abs(z+i-m);
        ans = add(ans, mul(C(x-m, i), mul(2,cur)));
    }
    return add(x-m, mul(ans, inv(p2[x-m])));
}
int main(){
    init();
    int T; cin>>T;
    while(T--){
        int a[4];
        for(int i = 0; i<3; i++) scanf("%d",a+i);
        sort(a, a+3);
        printf("%d\n",cal(a[2],a[1],a[0]));
    }
}
```

----

## Good Contest（cf-edu81-F）

### 题意

​	给一个长度为$n$的数列，第$i$个数的区间为$[L_i,R_i]$，求数列单调不增序列的概率。

​	$1\le n\le 50, 0\le l<r\le 10^9$

### 思路

​	先对区间离散化：将每个区间$[L,R]$转化为$[L,R+1)$后，加入离散化数组$b$一起离散化。用点$L$可以表示$[b[L], b[L+1])$这一个区间，这样原区间可以用若干点表示。

​	然后考虑DP。设$dp[i][j]$表示第$i$个数取在第$j$个区间的合法数量，答案就是$dp[n][0]+…+dp[n][m]$（m为离散化后区间个数）。

​	计算$dp[i][j]$时考虑枚举1～i-1​为划分点$k$，表示1～k取$>j$的区间，k+1～i取区间$j$。

​	（1）第一部分是dp[k][j+1]+…dp[k][m]，可以用前缀和维护。

​	（2）第二部分多重集组合数，公式为C(a+b-1, b)表示取b个数，套在本题就是C(len+(j-k)-1, j-k)，len是区间j的长度。

​	（3）两部分相乘就得到了划分点为k部分的计数。

### 代码

````c++
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define pii pair<int,int>
#define pli pair<ll,int>
#define fir first
#define sec second
using namespace std;
const int mod = 998244353;
const int maxn = 110;
int add(int a,int b){return a+b>=mod? a+b-mod:a+b;}
int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b&1) ret = mul(ret, a);
        a = mul(a,a);
    }
    return ret;
}
int rev(int x){return qpow(x,mod-2);}
int C(int n,int m){
    int ret = 1;
    for(int i = 1; i<=m; ++i){
        ret = mul(ret, mul(n-i+1, rev(i)));
    }
    return ret;
}
int n, l[maxn], r[maxn];
int b[maxn], m;
int dp[maxn][maxn];
int main(){
    cin>>n;
    int fm = 1;
    for(int i = 1; i<=n; i++){
        scanf("%d%d",l+i,r+i);
        b[m++] = l[i]; b[m++] = ++r[i];
        fm = mul(fm,r[i]-l[i]);
    }
    sort(b,b+m);
    m = unique(b,b+m)-b;
    for(int i = 1; i<=n; i++) {
        l[i] = lower_bound(b,b+m,l[i]) - b;
        r[i] = lower_bound(b,b+m,r[i]) - b;
    }
    memset(dp,0,sizeof(dp));
    for(int j = 0; j<m; j++) dp[0][j] = 1;
    for(int i = 1; i<=n; i++){
        for(int j = l[i]; j<r[i]; ++j){
            for(int k = i; k>0; --k){
                if(j < l[k] || j >= r[k]) break;
                int num = i-k+1;
                dp[i][j] = add(dp[i][j], mul(dp[k-1][j+1], C(num+b[j+1]-b[j]-1,num)));
            }
        }
        for(int j = m-2; j>=0; --j){
            dp[i][j] = add(dp[i][j],dp[i][j+1]);
        }
    }
    cout<<mul(dp[n][0],rev(fm))<<endl;
}
````

---

## 礼物箱（EOJ Monthly 2020.9）

### 题意

​	一个礼物箱种有$n$种不同的礼物，第$i$种礼物有$a_i$件。

​	每次随机抽取一件礼物，不放回。

​	问期望抽取多少次可以收集到每一种礼物。

​	$1\le n\le 290, 1\le a_i\le 2000, \sum a_i\le 2000$

### 思路

​	令$X_i$表示搜集到第$i$种礼物时搜集到的礼物数量，设$S=\{X_1,X_2,...,X_n\}$。

​	那么所求即为：$Y=max(S)$。

​	由$min-max$容斥，有：$Y=max(S)=\sum_{T\subseteq S}(-1)^{|T|-1}min(T)$。

​	考虑如何计算$min(T)$：

​		设$\sum_{X_i\in T}a_i=a,\sum a_i =b$，

​		问题转化为：一个盒子里有$a$白球、$b-a$黑球，每次拿出一个球，问第一次拿到白球时，已经拿出球的个数期望。

​		那么有：$min(T)=\sum_{i=0}^{b-a}\frac{C_{b-a}^i}{C_b^i}\times \frac{a}{b-i}\times (1+i)$。

​	$min(T)$最多有2000种情况，暴力计算即可。

### 代码

```c++
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fir first
#define sec second
#define pb push_back
#define ll long long
using namespace std;
const int mod = 998244353;
const int N = 25;
const int M = 2e3+10;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
int fac[M], ifac[M];
inline int C(int n,int m){
    return mul(fac[n], mul(ifac[m],ifac[n-m]));
}
inline int inv(int x){
    return qpow(x, mod-2);
}
void init(){
    fac[0] = 1;
    for(int i=1; i<M; i++) fac[i] = mul(fac[i-1], i);
    ifac[M-1] = qpow(fac[M-1], mod-2);
    for(int i=M-2; i>=0; --i) ifac[i] = mul(ifac[i+1], i+1);
}
int a[N], f[M], b=0;
int cal(int a){
    if(f[a] != -1) return f[a];
    int ret = 0;
    for(int i=0; i<=b-a; i++){
        int cnt = mul(mul(mul(C(b-a,i), inv(C(b,i))), mul(a, inv(b-i))), i+1);
        ret = add(ret, cnt);
    }
    return f[a] = ret;
}
int main(){
    init();
    int n; cin>>n;
    for(int i=0; i<n; i++) scanf("%d",a+i), b += a[i];
    int D = (1<<n), ans = 0;
    memset(f, -1, sizeof(f));
    for(int i=1; i<D; i++){
        int cnt=0, sum = 0;
        for(int j=0; j<n; j++){
            if((i>>j) & 1) cnt++, sum += a[j];
        }
        if(cnt & 1) ans = add(ans, cal(sum));
        else ans = sub(ans, cal(sum));
    }
    cout<<ans<<endl;
    return 0;
}
```

-----

# 生成函数

---

## 无限手套（牛客）

### 题意

​	有$m$种宝石，每种宝石数量无限。第$i$种宝石有属性$a_i,b_i$，如果手套上第$i$种宝石有$x_i$个，那么手套力量为$\Pi a_ix_i^2+b_ix_i+1$。

​	$q$次询问，每次问如果能安装$n$块宝石，对于所有可能的安装方案，手套最终所能得到的力量和。

​	$1\le n,m,q\le 10^3, 0\le a_i,b_i\le 10^9$

### 思路

​	对于每种宝石生成函数为：

​		$\sum_{k=0}^{\infty}(a_ik^2+b_ik+1)x^k$

​	=$\sum_{k=0}^{\infty}x^k+b_i\sum_{k=0}^{\infty}kx^k+a_i\sum_{k=0}^{\infty}k^2x^k$

​	=$\frac{1}{1-x}+\frac{b_ix}{(1-x)^2}+\frac{a_ix(1+x)}{(1-x)^3}$

​	=$\frac{(a_i-b_i+1)x^2+(a_i+b_i-2)x+1}{(1-x)^3}$

​	m种宝石的生成函数相乘：

​		$\frac{\Pi[(a_i-b_i+1)x^2+(a_i+b_i-2)x+1])}{(1-x)^{3m}}$

​	对于$\frac{1}{(1-x)^{3m}}$，用幂级数展开：

​		$(1-x)^{-n}$

​	=$C_{-n}^{0}+C_{-n}^1(-x)^1+C_{-n}^2(-x)^2+...$

​	=$\sum_{i=0}^{\infty}C_{n+i-1}^ix^i$

​	问题转化为两多项式相乘，最后$x^n$的系数即为所求。

​	对于两多项式相乘的部分，可以进一步用NTT优化。

### 代码

```c++
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fir first
#define sec second
#define pb push_back
#define ll long long
using namespace std;
const int mod = 998244353;
const int G = 3;
const int N = 1e5+10;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
int qpow(int a,int b){
    int ret=1;
    for(; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
int wn[N<<2], rev[N<<2];
int NTT_init(int pn){
    int step=0, n = 1;
    for(; n<pn; n<<=1) ++step;
    for(int i=1; i<=n; i++){
        rev[i] = (rev[i>>1]>>1)|((i&1)<<(step-1));
    }
    int g = qpow(G, (mod-1)/n);
    wn[0] = 1;
    for(int i=1; i<=n; i++){
        wn[i] = mul(wn[i-1], g);
    }
    return n;
}
void NTT(int a[], int n,int f){
    for(int i=0; i<=n; i++){
        if(i<rev[i]) swap(a[i], a[rev[i]]);
    }
    for(int k=1; k<n; k<<=1){
        for(int i=0; i<n; i+=(k<<1)){
            int t=n/(k<<1);
            for(int j=0; j<k; j++){
                int w = (f==1)? wn[t*j]:  wn[n-t*j];
                int x = a[i+j];
                int y = mul(a[i+j+k], w);
                a[i+j] = add(x, y);
                a[i+j+k] = sub(x, y);
            }
        }
    }
    if(f == -1){
        int ninv = qpow(n, mod-2);
        for(int i=0; i<=n; i++){
            a[i] = mul(a[i], ninv);
        }
    }
}
int f[N<<2], finv[N<<2], inv[N<<2];
inline int C(int n,int m){
    return mul(f[n], mul(finv[n-m], finv[m]));
}
void init(){
    inv[1] = 1;
    for(int i=2; i<N; i++) inv[i]=mul(sub(mod, mod/i), inv[mod%i]);
    f[0] = finv[0] = 1;
    for(int i=1; i<N; i++){
        f[i] = mul(f[i-1], i);
        finv[i] = mul(finv[i-1], inv[i]);
    }
}
int x[N<<2]{0}, y[N<<2]{0}, ans[N<<2];
int main(){
    int m; cin>>m;
    x[0] = 1;
    for(int i = 1; i<=m; i++) {
        int a, b; scanf("%d%d",&a,&b);
        a = a%mod, b = b%mod;
        int A = add(sub(a,b), 1), B = sub(add(a,b),2), C = 1;
        for(int j=2*i; j>=2; --j){
            x[j] = add(add(mul(x[j],C), mul(x[j-1],B)), mul(x[j-2],A));
        }
        x[1] = add(mul(x[1],C), mul(x[0], B));
        x[0] = mul(x[0], C);
    }
    init();
    for(int i = 0; i<N; i++){
        y[i] = C(3*m+i-1, i);
    }
    int n = NTT_init(1e5);
    NTT(x, n, 1); NTT(y, n, 1);
    for(int i=0; i<=n; i++) ans[i] = mul(x[i], y[i]);
    NTT(ans, n, -1);
    int q; cin>>q;
    while(q--){
        int tn; scanf("%d",&tn);
        printf("%d\n",ans[tn]);
    }
    return 0;
}
```

---

## Sub-cycle Graph（2018 ICPC Qingdao ）

### 题意

​	定义一张n点的无向图为 "sub-sycle" 图，当且仅当这张图可以通过增加任意条边之后变成一个长度为$n$的环。

​	现在给出点数$n$和边数$m$，问有多少张不同的$n$点$m$边的 "sub-sycle" 图。

​	$T\le 2\times 10^4, n\le 1e5, \sum n\le 3\times 10^7$

### 思路

​	问题实际要求$n$个不同点分成$m$条链的情况数。

​	可以将结点p排序的情况$n!$先提取出来，用生成函数计算不区分点的链条情况

​	设普通型生成函数$F(x)=a_0+a_1x+a_2x^2+...+a_nx^n$来表示一条链的情况，幂次等于这条链有多少结点。则n个结点$k$条链的情况为$F(x)^k$的结果中$x^n$的系数。

​	如果只考虑不考虑区分结点，那么有$a_0=0,a_1 = 1,a_i=1(i>1)$。但是当区分结点时，如果链条结点数$>1$时，在计算由于空间对称要除以2。而这一部分可以直接放在生成函数中计算，即设$a_i=\frac{1}{2}(i>1)$。

​	由于生成函数计算的方法，实际得到的是链条排序的情况，所以还要除以$(n-m)!$。

​	因此，最终结果为$F(x)^k$中$x^n$的系数$\times \frac{n!}{(n-m)!}$。

​	考虑如何计算$F(x)^k$中$x^n$的系数：

​		$F(x)=x+\frac{1}{2}x^2+\frac{1}{2}x^3+...$

​					$=\frac{x-\frac{1}{2}x^2}{1-x}$

​		$F(x)^k=\frac{x^k(1-\frac{1}{2}x)^k}{(1-x)^k}$

​		其中，

​			$(1-\frac{1}{2}x)^k=\sum_{i=0}^k(-\frac{1}{2})^iC_k^ix^i$；

​			$(1-x)^{-k}=\sum_{i=0}^{\infty}C_{k+i-1}^ix^i$

​		$O(n)$求解即可。

### 代码

```c++
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fir first
#define sec second
#define pb push_back
#define ll long long
using namespace std;
const int mod = 1e9+7;
const int N = 1e5+10;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
int qpow(int a,int b){
    int ret=1;
    for(; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
int f[N], finv[N];
void init(){
    f[0] = 1;
    for(int i=1; i<N; i++) f[i] = mul(f[i-1], i);
    finv[N-1] = qpow(f[N-1], mod-2);
    for(int i=N-2; i>=0; --i) finv[i] = mul(finv[i+1], i+1);
}
inline int C(int n,int m){
    return mul(f[n], mul(finv[n-m], finv[m]));
}
int main(){
    init();
    int T; cin>>T;
    int inv2 = qpow(2, mod-2);
    while(T--){
        int n;ll m; scanf("%d%lld",&n,&m);
        if(m > n) {
            puts("0"); continue;
        }
        if(m == n){
            printf("%d\n",mul(f[n-1], inv2)); continue;
        }
        int ans = 0, base = 1;
        int k = n-m;
        for(int i=0; i<=min(k, n-k); i++){
            int t = mul(mul(base, C(k, i)), C(k+(n-k-i)-1, k-1));
            ans = add(ans, t);
            base = mul(base, sub(0, inv2));
        }
        printf("%d\n",mul(ans, mul(f[n], finv[k])));
    }
}
```

-----

# EXGCD

## Fraction Construction Problem（牛客2020多校 F）

## 题意

​	$T$次询问。每次询问给两个正整数$a,b$。

​	输出正整数$c,d,e,f$（若有解），使得

​	（1）$\frac{c}{d}-\frac{e}{f} = \frac{a}{b}$

​	（2）$d<b$且$f<b$

​	（3）$1\leq c,e\leq 4\times10^{12}$

​	$1\leq T\leq 10^5, 1\leq a,b\leq 2\times 10^6$

## 思路

（1）当$(a,b)\neq 1$时：

可以构造答案$\frac{a}{(a,b)}+1,\frac{b}{(a,b)},1,\frac{b}{(a,b)}$。

（2）当$(a,b)=1$时：

1、若$b$质因子个数=1：

​	无解。

​	证明：

​		假设$b=p^k$，由于$a,b$互质，所以$\frac{c}{d}-\frac{e}{f}$化为最简分数后，必须是$\frac{a}{b}$，但$d$和$f$质因数分解中$p$的质数都$<k$，矛盾。

2、若$b$质因数个数$>1$：

​	必然有解，

​	证明：

​		找到$d,f$，满足$d\times f =b ,(d,f)=1$

​		$\frac{c}{d}-\frac{e}{f}=\frac{c\times f-e\times d}{d\times f}=\frac{a}{b}$，即找到$c,e$满足$c\times f-e\times d=a$，EXGCD求解即可。

​	具体做法：

​		找到$b$的两个质因子$d_1,d_2,(d_1,d_2)=1$。

​		令$d=\frac{b}{d_1},f=\frac{b}{d_2}$，那么问题变为求解$d_1\times c-d_2\times e=a$，进一步转化为求$a(d_1\times c'+d_2\times e')=a$。用$EXGCD$，先得到$c_0,e_0$。

​		答案还限制$1\leq c, e\leq 4\times 10^{5}$。我们要找到一组解$c',e'$满足$c'>0,e'<0,|c'|\times a\leq 4\times 10^{12}, |e'|\times a\leq 4\times 10^{12}$。

​		将$c',e'$写为$c'=\frac{b}{d_1}\times k_c+b_c, e'=\frac{b}{d_2}\times k_e+b_e$，其中$b_c>0, |b_c|<\frac{b}{d_1},b_e<0,|b_e|<\frac{b}{b_e}$，由于$a(d_1\times c'+d_2\times e')=a(b(k_c+k_e)+d_1\times b_c+d_2\times b_e)=a$，而$(b,a)=1$，所以$a(d_1\times b_c+d_2\times b_e)=a$，即$b_c,b_e$是一组可行解。显然，他们的符号和大小均满足要求。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define fir first
#define sec second
const int N = 2e6+10;
int p[N]{0}, m = 0, d1[N]{0}, d2[N]{0};
void init(){
    for(int i = 2; i<N; i++){
        if(!d1[i]){
            p[m++] = i;
            d1[i] = i;
        }
        for(int j = 0; j<m; j++){
            if(p[j] > (N-1)/i) break;
            d1[i*p[j]] = p[j];
            if(i%p[j]) d2[i*p[j]] = d1[i];
            else {
                d2[i*p[j]] = d2[i];
                break;
            }
        }
    }
}
ll exgcd(ll a,ll b,ll &x,ll &y){
    if(b == 0){
        x = 1, y = 0;
        return a;
    }
    ll d = exgcd(b, a%b, x, y);
    ll z = x; x = y, y = z - y*(a/b);
    return d;
}
int main(){
    init();
    int T; cin>>T;
    while(T--){
        ll a, b, x, y; scanf("%lld%lld\n",&a,&b);
        ll g = exgcd(a, b, x, y);
        if(g != 1) printf("%lld %lld %lld %lld\n",a/g+1,b/g,1LL,b/g);
        else if(!d2[b]) puts("-1 -1 -1 -1");
        else {
            exgcd(d1[b],d2[b],x,y);
            ll t1 = b/d1[b], t2 = b/d2[b];
            x = (x%t1 + t1)%t1;
            y = (y%t2 - t2)%t2;
            printf("%lld %lld %lld %lld\n",a*x,t1,-a*y,t2);
        }
    }
}
```

## 击鼓传花（EOJ Monthly 2020.9）

### 题意

​	有$n$个人围成一个环，从第$s$人开始传花，每个人将花传给向后数第$x$个人。对传花的人进行编号（从0开始，0,1,2,...），问在区间$[l,r]$的人第一次被编号的号码（如果始终不会被编号，则输出-1）。

​	由于围成一个环，如果$l\le r$，则表示区间$[l,r]$，否则表示$[r,n-1]$和$[0,l]$。

​	$T\le 10^5, 2\le n\le 10^9, 1\le x\le 10^9, 0\le s,l,r\le n-1$。

### 思路

​	首先，问题可以转化为从0开始，环的长度为$b$，每次跳$a$步，第一次跳到区间$[l,r],l\le r$所用次数。

​	即求解最小的自然数$x$，满足$l\le ax\ mod\ b\le r$，记为$f(a,b,l,r)$。

​	分情况讨论：

​	（1）若$\lceil \frac{l}{a}\rceil \le \lfloor \frac{r}{a}\rfloor $，

​		则$f(a,b,l,r)=\lceil \frac{l}{a}\rceil $

​	（2）否则，

​		存在$M\in N^*$，使得$aM<l\le r< a(M+1)$。

​		$aM<l\le ax-bk\le r<a(M+1)$

​	$\Rightarrow -a(M+1)<-r\le bk-ax\le -l< -aM$

​	$\Rightarrow a(x-M-1)<-r+ax\le bk\le -l+ax<a(x-M)$

​		而$k$即为$f(b\ mod\ a ,a,(-r)\ mod\ a, (-l)\ mod\ a)$。

​		递归求解即可。

​		注意判断无解的情况：

​	（1）$a=0$：上一层没有得到答案，所以必有$0\not\in [l,r]$，所以无解。

​	（2）$l>r$：上一层的不等式必然无解。

### 代码

```c++
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fir first
#define sec second
#define pb push_back
#define ll long long
using namespace std;
const ll inf = 1e18;
inline ll tsf(ll x,ll mod){return (x%mod+mod)%mod;}
ll f(ll a, ll b, ll l, ll r){
    if(!a || l>r) return inf;
    ll t1 = (l+a-1)/a, t2 = r/a;
    if(t1 <= t2) return t1;
    ll k = f(tsf(b,a), a, tsf(-r,a), tsf(-l,a));
    if(k == inf) return inf;
    return (l+k*b + a-1)/a;
}
int main(){
     int T; cin>>T;
     while(T--){
         ll x, n, s, l, r;
         scanf("%lld%lld%lld%lld%lld",&x,&n,&s,&l,&r);
         l =tsf(l-s, n), r=tsf(r-s, n);
         ll ans = (l>r)? min(f(x,n,l,n-1),f(x,n,0,r)): f(x,n,l,r);
         if(ans == inf) puts("-1");
         else printf("%lld\n",ans);
     }
     return 0;
}
```

----

# 斐波那契

---

## Fibonacci Sum（2020hdu多校1）

### 题意

​	给出$N,C,K$，求$(F_C)^K+(F_{2C})^K+...+(F_{NC})^K(mod\ 10^9+9)$。

​	$1\le N,C\le10^{18},1\le K\le10^5$

### 思路

​	$F_n=\frac{1}{\sqrt5}[(\frac{1+\sqrt5}{2})^n-(\frac{1-\sqrt5}{2})^n]$。

​	注意到，$5^\frac{10^9+9-1}{2}\equiv 1(mod\ 10^9+9)$，即$x^2\equiv 5(mod\ 10^9+9)$有解。本地暴力预处理，得到$383008016^2\equiv 5(mod\ 10^9+9)$。

​	因此原通项公式可写为：$F_n\equiv d(a^n-b^n)(mod\ 10^9+9)$。

​	进一步$\sum_{i=1}^N(F_{Ci})^K\equiv \sum_{i=1}^N\{d(a^{Ci}-b^{Ci})\}^K\equiv d^K\sum_{j=0}^KC(K,j)\sum_{i=1}^N(-1)^j(a^{K-j}b^j)^{Ci}$。内层等比数列求和公式化简，外层枚举即可。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define pii pair<int, int>
#define pll pair<ll, ll>
#define pss pair<string, string>
#define pdd pair<double, double>
#define fir first
#define sec second
const int mod = 1e9+9;
int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
int sub(int a,int b){return a<b? a-b+mod: a-b;}
int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,ll b){
    int ret = 1;
    for( ; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return  ret;
}
const int N = 1e5+10;
int jc[N], rjc[N];
void init(){
    jc[0] = 1;
    for(int i = 1; i<N; i++){
        jc[i] = mul(jc[i-1], i);
    }
    rjc[N-1] = qpow(jc[N-1],mod-2);
    for(int i = N-2; i>=0; --i){
        rjc[i] = mul(rjc[i+1], i+1);
    }
}
int C(int n,int m){
    return mul(jc[n], mul(rjc[m],rjc[n-m]));
}
int main(){
    init();
    int sqrt5 = 383008016, rev2 = qpow(2,mod-2);
    int d = qpow(sqrt5, mod-2);
    int a = mul(add(1,sqrt5),rev2);
    int ra = qpow(a, mod-2);
    int b = mul(sub(1,sqrt5),rev2);
    int T; cin>>T;
    while(T--){
        ll n, c; int k; scanf("%lld%lld%d",&n,&c,&k);
        int ans = 0, q = qpow(qpow(a,c), k), p = mul(qpow(ra,c), qpow(b,c));
        for(int j = 0; j<=k; j++){
            int t = (j & 1)? sub(mod, C(k,j)): C(k,j);
            if(q == 1) {
                ans = add(ans, mul(t,n%mod));
            } else {
                int sum  = mul(mul(q,sub(qpow(q,n%(mod-1)),1)), qpow(sub(q,1),mod-2));
                ans = add(ans, mul(t, sum));
            }
            q = mul(q, p);
        }
        printf("%d\n",mul(qpow(d,k), ans));
    }
}
```

----

