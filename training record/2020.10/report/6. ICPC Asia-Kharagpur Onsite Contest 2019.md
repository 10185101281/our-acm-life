# 6. ICPC Asia-Kharagpur Onsite Contest 2019

----

### 题意

​	给出一排$n$个气球和一个数字$k$，每个气球有一个颜色。

​	定义一个气球集合的价值为$\sum cnt_i^k$，其中$cnt_i$为第$i$个气球的个数。

​	问所有可能区间的价值和。

​	$1\le n,k\le 2\times 10^5$

### 思路

​	考虑单独计算每种颜色气球的贡献，然后求累加。

​	以$A$类颜色气球为例：

​		$-a_1-A-a_2-A-a_3-A-a_4-$

​	贡献为：

​		$(a_1a_2+a_2a_3+a_3a_4)\times 1^k+(a_1a_3+a_2a_4)\times 2^k+(a_1a_4)\times 3^k$

​	预处理每种气球的分割区间，然后用FFT计算即可。

### 代码

```c++
#include <bits/stdc++.h>
#define pii pair<int,int>
#define fir first
#define sec second
#define pb push_back
#define ll long long
using namespace std;
const int N = 1e6+10;
const int mod = 1e9+7;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}
int pk[N];
const double PI = acos(-1);
struct C{
    double r, i;
    C(double r = 0, double i = 0): r(r), i(i){}
};
C operator + (const C&a, const C&b){
    return C(a.r+b.r, a.i+b.i);
}
C operator - (const C&a, const C&b){
    return C(a.r-b.r, a.i-b.i);
}
C operator * (const C&a, const C&b){
    return C(a.r*b.r-a.i*b.i, a.r*b.i + a.i*b.r);
}
void FFT(C x[], int n, int p) {
    for (int i = 0, t = 0; i < n; ++i) {
        if (i > t) swap(x[i], x[t]);
        for (int j = n >> 1; (t ^= j) < j; j >>= 1);
    }
    for (int h = 2; h <= n; h <<= 1) {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i < n; i += h) {
            C w(1, 0), u;
            for (int j = i, k = h >> 1; j < i + k; ++j) {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1){
        for(int i = 0; i<=n; i++) x[i].r /= n;
    }
}

void conv(C a[], C b[], int n) {
    FFT(a, n, 1);
    FFT(b, n, 1);
    for(int i = 0; i<=n; i++){
        a[i] = a[i] * b[i];
    }
    FFT(a, n, -1);
}

C a[N*4], b[N*4];
int cal(vector<int> & vec){
    int tn = vec.size();
    int n = 1;
    while(n < 2*tn) n <<= 1;
    for(int i=0; i<=n; i++) a[i] = b[i] = {0, 0};

    for(int i=0; i<tn; i++) a[i].r = vec[i], b[i].r = vec[tn-i-1];
    conv(a, b, n);

    int ret = 0;
    for(int i=0; i<tn-1; i++){
        int val = (ll)(a[i].r + 0.5) % mod;
        ret = add(ret, mul(val, pk[tn-i-1]));
    }
    return ret;
}

map<int, int> pre;
map<int, vector<int>> mp;

int main(){
    int n, k; scanf("%d%d",&n,&k);
    for(int i=0; i<=n; i++) pk[i]=qpow(i, k);
    for(int i=1; i<=n; i++){
        int x;  scanf("%d",&x);
        if(!pre[x]){
            vector<int> tmp;
            tmp.pb(i);
            mp[x] = tmp;
        } else {
            mp[x].pb(i-pre[x]);
        }
        pre[x] = i;
    }
    for(auto &pr: pre) mp[pr.fir].pb(n-pr.sec+1);

    int ans = 0;
    for(auto &pr: mp){
        //cout<<pr.fir<<": "; for(auto &x: pr.sec) cout<<x<<','; cout<<endl;
        ans = add(ans, cal(pr.sec));
    }
    cout<<ans<<endl;
    return 0;
}
```