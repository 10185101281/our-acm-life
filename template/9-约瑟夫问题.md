# 9-约瑟夫问题

---

##Let the Flames Begin（2018icpc沈阳）

### 题意

​	约瑟夫环背景，n人第k个被选出，求第$m$个被选出来的人位置。

​	$1\le T\le1000, 1\le n,m,k\le 10^{18},\sum min\{m,k\}\le2\times 10^6$

### 思路

​	设每k个人选出一个，n个人第m个被选出来的标号为$A(n,m)$。

​	考虑如何递推。第一次被选出来的人一定是k-1，当他被选出来后，问题转化为了n-1的选出m-1个人。考虑将最终结果进行坐标变换即可。

​	那么有递推式：

​	$A(n,m)=(A(n-1,m-1)+k)\%n$

​	由于限制$\sum min\{m,k\}\le2\times 10^6$，考虑分情况讨论：

​	（1）当m较小时：

​	直接递推，复杂度为$O(m)$。

​	（2）当$k$较小时：

​	当$A(n-1,m-1)+k<n$时，不需要$\%n$，可以利用这一点加速递推：

​			$A+xk<n+x$

​	$\Rightarrow x(k-1)<n-A$

​	$\Rightarrow x<\frac{n-A}{k-1}$

​	这样复杂度接近$O(k)$。

​	注意对$k==1$的时候，特判一下。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define pii pair<int, int>
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pss pair<string, string>
#define pdd pair<double, double>
#define fir first
#define sec second
const int N = 2e6+10;
const int base = 2e6+10;
ll f(ll n,ll m,ll k){
    if(m == 1) return (k-1)%n;
    return (f(n-1,m-1,k)+k)%n;
}
int main(){
    int T; cin>>T;
    for(int cs = 1; cs<=T; cs++){
        printf("Case #%d: ",cs);
        ll n, m, k; scanf("%lld%lld%lld",&n,&m,&k);
        if(k == 1) {
            printf("%lld\n",m);
            continue;
        }
        if(m <= base) printf("%lld\n",f(n,m,k)+1);
        else {
            ll tn = n-m+1;
            ll ans = (k-1)%tn;
            ll now = 1;
            while(now < m){
                if(ans+k >= tn+1){
                    tn++;
                    ans = (ans+k)%tn;
                    now++;
                    continue;
                }
                ll x = (tn-ans-1)/(k-1);
                x = min(x, m-now);
                now += x;
                ans += k*x;
                tn += x;
            }
            printf("%lld\n",ans+1);
        }
    }
}
```

-----

## Josephus Transform（2020牛客多校-6）

### 题意

​	给一个排列$P=\{1,2,3,...,n\}$。

​	定义$k-Josephus\ transform$：不断选出第k个，直到组成一个新的排列。

​	m次操作。每次操作给出x,k，令排列进行$x$次$k-Josephus\ transform$。

​	所有操作结束后，回答最终排列的情况。

​	$1\le n,m\le 10^5,1\le n\times m\le 10^6,1≤k≤n,1≤x≤10^9$

### 思路

​	对于一次$k-Josephus\ transform$，实际上就是求出被选出的第$1,2,3,...,n$个人的所有的标号。我们可以利用线段树，整体$O(nlogn)$处理出答案。

​	得到置换群后。问题就是求进行$x$次置换操作后，每个数的位置。可以处理出置换群中的每个环，然后$O(1)$的找到最终位置，这样复杂度与$k$无关，整体复杂度是$O(n)$的。

​	共$m$次操作，复杂度为$O(nmlogn)$。	

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define pii pair<int, int>
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pss pair<string, string>
#define pdd pair<double, double>
#define fir first
#define sec second
const int N = 1e5+10;
struct node{
    int l, r, sum;
}T[N*4];
void build(int p,int L,int R){
    T[p].l = L; T[p].r = R;
    if(L == R){
        T[p].sum = 1;
        return ;
    }
    int mid = (L+R)/2;
    build(p*2, L, mid);
    build(p*2+1, mid+1, R);
    T[p].sum = T[p*2].sum+T[p*2+1].sum;
}
int query(int p,int pos){
    T[p].sum --;
    if(T[p].l == T[p].r) return T[p].l;
    if(T[p*2].sum >= pos) return query(p*2, pos);
    else return query(p*2+1, pos-T[p*2].sum);
}
int a[N], ans[N], to[N], v[N], tmp[N];
vector<int> circle;
void tsf(int n,int x){
    for(int i = 1; i<=n; i++) v[i] = 0;
    for(int i = 1; i<=n; i++){
        if(v[i]) continue;
        circle.clear();
        int t = i;
        while(!v[t]){
            circle.pb(t);
            v[t] = 1;
            t = to[t];
        }
        int sz = (int)circle.size();
        for(int j = 0; j<sz; j++){
            tmp[circle[(j+x)%sz]] = a[circle[j]];
        }
    }
    for(int i = 1; i<=n; i++) a[i] = tmp[i];
}
int main(){
    int n, m; cin>>n>>m;
    for(int i = 1; i<=n; i++) a[i] = i;
    while(m--){
        build(1, 1, n);
        int k, x; scanf("%d%d",&k,&x);
        int pos = 1;
        for(int i = 1; i<=n; i++){
            pos = (pos-1+k-1) % (n-i+1) + 1;
            to[query(1, pos)] = i;
        }
        tsf(n, x);
    }
    for(int i = 1; i<=n; i++) printf("%d%c",a[i]," \n"[i==n]);
}
```

 