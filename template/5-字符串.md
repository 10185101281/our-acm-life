## 后缀
1) SAM

```cpp
struct SAM{
 
	int tot=1,last=1;//last -> 旧主串的节点
	int fa[maxn],len[maxn];
	ll size[maxn];
	int cup[maxn],mp[maxn];
	int son[maxn][maxc];
	int val[maxn];
	int minp[maxn],maxp[maxn]; 
	
	//1 号节点为初始节点 初始节点没有fa
	
	//建SAM
	void extend (int c , int cao)
	{
 
	    int p=last,np=++tot;
	    last=tot,len[np]=len[p]+1;
	    while (p&&!son[p][c])   son[p][c]=np,p=fa[p];
	   
	    if (!p) fa[np]=1,val[np] = tp;
	    else{
	       
	        int q=son[p][c];
	        if (len[q]==len[p]+1) fa[np]=q;//val[np]=tp;
	        else{
	           
	            int nq=++tot;
	            len[nq]=len[p]+1;
	            fa[nq]=fa[q];
	            fa[np]=fa[q]=nq;
	            memcpy(son[nq],son[q],sizeof(son[q]));
	            while (son[p][c]==q)   
					son[p][c]=nq,p=fa[p];
				//val[np] = tp;
	        }
	    }
	    size[np]=1;//该节点right大小初值赋值为1
	  	minp[np] = maxp[np] = cao;
	}
	void dfs(int k)
	{
		size[k] = 1;
		for (int i = 0 ; i < 26 ; ++i)
		{
			int p = son[k][i];
			if(p)
			{
				if(!size[p])
					dfs(p);
				size[k] += size[p]; 
			}
		}	
	}
	
	void getSize(){
	//	cout << len[last]<<endl;
		for (int i = 1 ; i <=tot;++i) cup[len[i]] = 0;
		for (int i=1;i<=tot;++i)    ++cup[len[i]];
		for (int i=1;i<=tot;++i)    cup[i]+=cup[i-1];
		for (int i=1;i<=tot;++i)    mp[cup[len[i]]--]=i;
		
		for (int i=tot;i>=1;--i)  
		{
			int p = mp[i];
		  	size[fa[p]]+=size[p];
		  	minp[fa[p]] = min(minp[fa[p]],minp[p]);
		  	maxp[fa[p]] = max(maxp[fa[p]],maxp[p]);
		}
	}
 
    inline void init()
    {
        last = tot = 1;
        fa[1]=0;
        memset(son,0,sizeof(son));
    }
 
}sam; 
```
 2) 广义SAM (多串)
 仅修改extend，新插入串令last = 1
 ```cpp
 	int extend (int c)
	{
		
		if(son[last][c]){
			int p = last , x = son[p][c];
			if(len[p] + 1 == len[x]) return last = x;
			else{
				int y = ++tot; len[y] = len[p] + 1;
				for (int i = 0 ; i < 26 ; ++i) son[y][i] = son[x][i];
				while(p && son[p][c] == x) son[p][c] = y , p = fa[p];
				fa[y] = fa[x], fa[x] = y;
				return last = y; 
			}
		}
		
	    int p=last,np=++tot;
	    last=tot,len[np]=len[p]+1;
	    while (p&&!son[p][c])   son[p][c]=np,p=fa[p];
	   
	    if (!p) fa[np]=1;
	    else{
	       
	        int q=son[p][c];
	        if (len[q]==len[p]+1) fa[np]=q;//val[np]=tp;
	        else{
	           
	            int nq=++tot;
	            len[nq]=len[p]+1;
	            fa[nq]=fa[q];
	            fa[np]=fa[q]=nq;
	            memcpy(son[nq],son[q],sizeof(son[q]));
	            while (son[p][c]==q)   
					son[p][c]=nq,p=fa[p];
				//val[np] = tp;
	        }
	    }
	    size[np]=1;//该节点right大小初值赋值为1
	    return np;
	}
 ```

3)后缀数组

```cpp
const int N = 500005;
int sa[N],s[N],wa[N], wb[N], WS[N], wv[N];
int _rank[N], height[N];
 
bool cmp(int r[], int a, int b, int l)
{
    return r[a] == r[b] && r[a+l] == r[b+l];
}
 
void da(int r[], int sa[], int n, int m)
{
    int i, j, p, *x = wa, *y = wb;
    for (i = 0; i < m; ++i) WS[i] = 0;
    for (i = 0; i < n; ++i) WS[x[i]=r[i]]++;
    for (i = 1; i < m; ++i) WS[i] += WS[i-1];
    for (i = n-1; i >= 0; --i) sa[--WS[x[i]]] = i;
    for (j = 1, p = 1; p < n; j *= 2, m = p)
    {
        for (p = 0, i = n - j; i < n; ++i) y[p++] = i;
        for (i = 0; i < n; ++i) if (sa[i] >= j) y[p++] = sa[i] - j;
        for (i = 0; i < n; ++i) wv[i] = x[y[i]];
        for (i = 0; i < m; ++i) WS[i] = 0;
        for (i = 0; i < n; ++i) WS[wv[i]]++;
        for (i = 1; i < m; ++i) WS[i] += WS[i-1];
        for (i = n-1; i >= 0; --i) sa[--WS[wv[i]]] = y[i];
        for (std::swap(x, y), p = 1, x[sa[0]] = 0, i = 1; i < n; ++i)
            x[sa[i]] = cmp(y, sa[i-1], sa[i], j) ? p-1 : p++;
    }
    for (int i = 0 ; i < n ; ++i) _rank[sa[i]] = i;
}
```

