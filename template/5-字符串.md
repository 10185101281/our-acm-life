# 5-字符串

----

## 5.1 后缀

### 5.1.1 SAM

```cpp
struct SAM{
 
	int tot=1,last=1;//last -> 旧主串的节点
	int fa[maxn],len[maxn];
	ll size[maxn];
	int cup[maxn],mp[maxn];
	int son[maxn][maxc];
	int val[maxn];
	int minp[maxn],maxp[maxn]; 
	
	//1 号节点为初始节点 初始节点没有fa
	
	//建SAM
	void extend (int c , int cao)
	{
 
	    int p=last,np=++tot;
	    last=tot,len[np]=len[p]+1;
	    while (p&&!son[p][c])   son[p][c]=np,p=fa[p];
	   
	    if (!p) fa[np]=1,val[np] = tp;
	    else{
	       
	        int q=son[p][c];
	        if (len[q]==len[p]+1) fa[np]=q;//val[np]=tp;
	        else{
	           
	            int nq=++tot;
	            len[nq]=len[p]+1;
	            fa[nq]=fa[q];
	            fa[np]=fa[q]=nq;
	            memcpy(son[nq],son[q],sizeof(son[q]));
	            while (son[p][c]==q)   
					son[p][c]=nq,p=fa[p];
				//val[np] = tp;
	        }
	    }
	    size[np]=1;//该节点right大小初值赋值为1
	  	minp[np] = maxp[np] = cao;
	}
	void dfs(int k)
	{
		size[k] = 1;
		for (int i = 0 ; i < 26 ; ++i)
		{
			int p = son[k][i];
			if(p)
			{
				if(!size[p])
					dfs(p);
				size[k] += size[p]; 
			}
		}	
	}
	
	void getSize(){
	//	cout << len[last]<<endl;
		for (int i = 1 ; i <=tot;++i) cup[len[i]] = 0;
		for (int i=1;i<=tot;++i)    ++cup[len[i]];
		for (int i=1;i<=tot;++i)    cup[i]+=cup[i-1];
		for (int i=1;i<=tot;++i)    mp[cup[len[i]]--]=i;
		
		for (int i=tot;i>=1;--i)  
		{
			int p = mp[i];
		  	size[fa[p]]+=size[p];
		  	minp[fa[p]] = min(minp[fa[p]],minp[p]);
		  	maxp[fa[p]] = max(maxp[fa[p]],maxp[p]);
		}
	}
 
    inline void init()
    {
        last = tot = 1;
        fa[1]=0;
        memset(son,0,sizeof(son));
    }
 
}sam; 
```
 ### 5.1.2 广义SAM (多串)
 仅修改extend，新插入串令last = 1,在树上建广义sam，也可令last等于某个节点曾经的last值
 由于是return后使用，记得在return后更新属性
 
 ```cpp

 	int extend (int c)
	{
		
		if(son[last][c]){
			int p = last , x = son[p][c];
			if(len[p] + 1 == len[x]) return last = x;
			else{
				int y = ++tot; len[y] = len[p] + 1;
				for (int i = 0 ; i < 26 ; ++i) son[y][i] = son[x][i];
				while(p && son[p][c] == x) son[p][c] = y , p = fa[p];
				fa[y] = fa[x], fa[x] = y;
				return last = y; 
			}
		}
		
	    int p=last,np=++tot;
	    last=tot,len[np]=len[p]+1;
	    while (p&&!son[p][c])   son[p][c]=np,p=fa[p];
	   
	    if (!p) fa[np]=1;
	    else{
	       
	        int q=son[p][c];
	        if (len[q]==len[p]+1) fa[np]=q;//val[np]=tp;
	        else{
	           
	            int nq=++tot;
	            len[nq]=len[p]+1;
	            fa[nq]=fa[q];
	            fa[np]=fa[q]=nq;
	            memcpy(son[nq],son[q],sizeof(son[q]));
	            while (son[p][c]==q)   
					son[p][c]=nq,p=fa[p];
				//val[np] = tp;
	        }
	    }
	    size[np]=1;//该节点right大小初值赋值为1
	    return np;
	}
 ```

### 5.1.3 后缀数组
下标均从1开始

```cpp
const int maxn = 5e5 + 100;
int x[maxn], y[maxn], sa[maxn], c[maxn], height[maxn], rak[maxn];
int rk[maxn], trk[maxn], tsa[maxn];
int n, m;
int s[maxn];
 
//均为1开始下标 
void build_sa()
{
    for (int i = 1; i <= n; i++)c[i] = 0;
    for (int i = 1; i <= n; i++)c[s[i]]++;
    for (int i = 1; i <= m; i++)c[i] += c[i - 1];
    for (int i = n; i; i--)sa[c[s[i]]--] = i;
    rk[sa[1]] = 1; int p = 1;
    for (int i = 2; i <= n; i++)
    {
        if (s[sa[i]] != s[sa[i - 1]]) p++;
        rk[sa[i]] = p;
    }
    m = p;
    for (int j = 1; m < n; j *= 2)
    {
        p = 0;
        for (int i = 1; i <= m; i++)
            c[i] = 0;     
        for (int i = 1; i <= n; i++)
            trk[i] = rk[i];
        for (int i = n + 1; i <= n + j; i++)
            trk[i] = 0;
        for (int i = n - j + 1; i <= n; i++)tsa[++p] = i;
        for (int i = 1; i <= n; i++)if (sa[i] > j)tsa[++p] = sa[i] - j;
        for (int i = 1; i <= n; i++)c[trk[tsa[i]]]++;
        for (int i = 1; i <= m; i++)c[i] += c[i - 1];
        for (int i = n; i; i--)sa[c[trk[tsa[i]]]--] = tsa[i];
        p = 1;
        rk[sa[1]] = 1;
        for (int i = 2; i <= n; i++)
        {
            if (trk[sa[i]] != trk[sa[i - 1]]|| trk[sa[i] + j] != trk[sa[i - 1] + j]) p++;
            rk[sa[i]] = p;
        }
        m = p;
    }
}
 
void getHeight(){
    int k=0;
    for(int i=1;i<=n;i++)
    {
        if(rk[i]==1) continue;
        if(k) k--;
        int j=sa[rk[i]-1];
        while(j+k<=n && i+k<=n && s[i+k]==s[j+k])
            k++;
        height[rk[i]]=k;
    }
}
 
 
int dp[maxn << 1][18] ;
 
void ST()
{
    memset(dp , 0x3f , sizeof(dp));
    for(int i=1 ; i<=n ; i++)dp[i][0]=height[i];
    for(int k=1 ; (1<<k)<=n ; k++){
        for(int i=1 ; i<=n ; i++){
            dp[i][k] = min(dp[i][k-1] , dp[i+(1<<(k-1))][k-1]);
        }
    }
}
 
int RMQ(int s , int t)
{
    int d = t-s+1;
    int k = (int)log2(d*1.0);
    return min(dp[s][k] , dp[t-(1<<k)+1][k]);
}
int RMQPOS(int x , int y)
{
	if(!x || !y) return 0; 
	if(x == y) return n - x + 1;
    x = rk[x] , y = rk[y];
    if(x>y){int t=x;x=y,y=t;}
    return RMQ(x+1,y);
}
```

### 5.2 Lydon Word

- 对于字符串$s$，若$s$的最小后缀为其本身，那么称$s$为Lyndon串。
- $s$为Lyndon串等价于$s$本身是其循环移位中最小的一个。
- Lydon分解：任意字符串$s$都可以分解为$s=s_1s_2…s_k$，其中$∀s_i$为Lyndon串且$s_i⩾s_{i+1}$。

```c++
for(int i = 1; i <= N;) {
      j = i; k = i + 1;
        while(k <= N && s[j] <= s[k]) {
            if(s[j] < s[k]) j = i;
            else j++;
            k++;
        }
        while(i <= j) {
            printf("%d ", i + k - j - 1);
            i += k - j;
        }
    }
```

### 5.2 在线AC自动机（二进制暴力）
```c++
struct AC{
	int tmp[MAXNODE][SIGMA_SIZE]; 
    int ch[MAXNODE][SIGMA_SIZE];
    int f[MAXNODE];
    int root[MAXNODE];
    int val[MAXNODE];
    int size[MAXNODE];
    int cnt[MAXNODE];
    int tot[MAXNODE];
    int sz;
    int totid;
    
    void init(){
        sz = 1;
        memset(ch[0],0,sizeof (ch[0]));
    }
    inline int idx(char c){
        return c-'a';
    }
    
    int Merge(int ls , int rs){
    	if(!ls || !rs) return ls + rs;
    	int rt = ls;
    	for (int i = 0  ; i < SIGMA_SIZE ; ++i) {
    		ch[rt][i] = Merge(ch[ls][i],ch[rs][i]);
		}
		cnt[rt] += cnt[rs];
		return rt;
	}
	
    void getfail( int rt ){
        queue<int> Q;
        for(int c= 0;c <  SIGMA_SIZE; c++){
            if(ch[rt][c] ){ f[ tmp[rt][c] = ch[rt][c] ] = rt; Q.push(tmp[rt][c]); }
            else tmp[rt][c] = rt;
        }
        while(!Q.empty()){
            int r = Q.front(); Q.pop();
            for(int c = 0;c <  SIGMA_SIZE; c++){
         
                if(!ch[r][c]){	tmp[r][c] = tmp[f[r]][c];}
                else
                {
                	f[tmp[r][c] = ch[r][c]] = tmp[f[r]][c];
                	Q.push(tmp[r][c]);
        
    				/*
                	while(v && !ch[v][c]) v= f[v];
                	f[u] = ch[v][c];
                	last[u] = val[f[u]]?f[u]:last[f[u]];
                	*/
				}
 
            }
            tot[r] = tot[f[r]] + cnt[r];
        }
    }
    
	void MyInsert(char * s){
		int n = strlen(s);
		root[++totid] = ++sz;
		size[totid] = 1;
		int u = root[totid],c;
		for (int i = 0 ; i < n ; ++i){
			c = idx(s[i]);
		
			ch[u][c] = ++sz;
			
			u = ch[u][c];
		}
		cnt[u]++;
		
		while(totid > 1 && size[totid] == size[totid-1]){
			root[totid-1] = Merge(root[totid-1],root[totid]);
			size[totid - 1] += size[totid];
			totid--;
		}
		getfail(root[totid]); 
	}
    
    int query(char * s){
    	int res = 0;
    	int n = strlen(s);
    	for (int i = 1 ; i <= totid ; ++i){
    		for (int u = root[i] , j = 0 ;j  < n ; ++j){
    			u = tmp[u][idx(s[j])];
    			res += tot[u];
			}
			//cout << res << endl;
		}
		return res;
	}
    
} In,Out;
```

后缀自动机+right集合
-------------
```c++
int rt[maxn];  
namespace tr
{
    #define mid ((l+r)>>1) 
    #define lson t[x].l
    #define rson t[x].r
    int cnt;
    int newnode() { return ++cnt; }
    struct Node{ int l,r,sumv; }t[maxn * 50];
    int merge(int u,int v)
    {
        if(!u||!v) return u+v;
        int x=newnode();
        t[x].sumv=t[u].sumv+t[v].sumv;
        lson=merge(t[u].l,t[v].l);
        rson=merge(t[u].r,t[v].r);
        return x;            
    }
    void update(int &x,int l,int r,int k,int delta)
    {
        if(!x)x=newnode();                
        t[x].sumv+=delta;
        if(l==r) return;
        if(k<=mid) update(lson, l, mid, k, delta);
        else update(rson, mid + 1, r, k, delta);  
    }
    int query(int x,int l,int r,int L,int R)
    {
        if(!x || L>R)return 0;
        if(l>=L&&r<=R) return t[x].sumv;
        int tmp=0;
        if(L<=mid) tmp+=query(lson,l,mid,L,R);
        if(R>mid) tmp+=query(rson, mid+1,r,L,R);
        return tmp;
    }  
    #undef lson
    #undef mid
    #undef rson 
};
namespace SAM
{
    int tot,last;
    int len[maxn], ch[maxn][30], f[maxn], rk[maxn], C[maxn];
    void init() { tot = last = 1; }
    void extend(int c)
    {
        int np=++tot,p=last;
        last=np, len[np]=len[p]+1;
        while(p&&!ch[p][c]) ch[p][c]=np,p=f[p];
        if(!p) f[np]=1;
        else
        {
            int q=ch[p][c];
            if(len[q]==len[p]+1) f[np]=q;
            else
            {
                int nq=++tot;
                len[nq]=len[p]+1;
                memcpy(ch[nq],ch[q],sizeof(ch[q]));
                f[nq]=f[q],f[np]=f[q]=nq;  
                while(p&&ch[p][c]==q) ch[p][c]=nq, p=f[p];
            }
        }
        tr::update(rt[np], 1, n, len[np], 1);  
    }
    void prepare()
    {
        int i,j;
        for(i=1;i<=tot;++i) ++C[len[i]];
        for(i=1;i<=tot;++i) C[i]+=C[i-1];
        for(i=1;i<=tot;++i) rk[C[len[i]]--]=i;           
        for(i=tot;i>=1;--i)
        {
            j=rk[i];
            rt[f[j]]=tr::merge(rt[f[j]], rt[j]);
        }   
    }
};
```

回文自动机
-----
```c++

namespace PAM {
    int next[MAXN][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成
    int fail[MAXN] ;//fail指针，失配后跳转到fail指针指向的节点
    int cnt[MAXN] ;
    int num[MAXN] ; //右端点的回文总个数
    int len[MAXN] ;//len[i]表示节点i表示的回文串的长度
    int S[MAXN] ;//存放添加的字符
    int last ;//指向上一个字符所在的节点，方便下一次add
    int nid ;//字符数组指针
    int p ;//节点指针
	static int isInit = 0;
    int newnode ( int l ) {//新建节点
        for ( int i = 0 ; i < N ; ++ i ) next[p][i] = 0 ;
        cnt[p] = 0 ;
        num[p] = 0 ;
        len[p] = l ;
        return p ++ ;
    }

    void init () {//初始化
        p = 0 ;
        isInit = 1;
        newnode (  0 ) ;
        newnode ( -1 ) ;
        last = 0 ;
        nid = 0 ;
        S[nid] = -1 ;//开头放一个字符集中没有的字符，减少特判
        fail[0] = 1 ;
    }

    int get_fail ( int x ) {//和KMP一样，失配后找一个尽量最长的
        while ( S[nid - len[x] - 1] != S[nid] ) x = fail[x] ;
        return x ;
    }

    void add ( int c ) {
    	if(isInit == 0) init(),isInit=1;
        S[++ nid] = c ;
        int cur = get_fail ( last ) ;
        if ( !next[cur][c] ) {
            int now = newnode ( len[cur] + 2 ) ;//新建节点
            fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转
            next[cur][c] = now ;
            num[now] = num[fail[now]] + 1 ;
        }
        last = next[cur][c] ;
        cnt[last] ++ ;
    }

    void count () {
        for ( int i = p - 1 ; i >= 0 ; -- i ) cnt[fail[i]] += cnt[i] ;
    }
} ;
```

哈希
--
```c++
struct My_Hash
{
    ull base=131;
    ull p[maxn],ha[maxn];
    void Insert(char s[])
    {
        int len=strlen(s+1);
        p[0]=1,ha[0]=0;
        for(int i=1;i<=len;i++)
        {
            p[i]=p[i-1]*base;
            ha[i]=ha[i-1]*base+(ull)s[i];
        }
    }
    ull gethash(int l,int r)
    {
        return (ull)ha[r]-ha[l-1]*p[r-l+1];
    }
}S;
```
