# 3-数据结构

---

## 3.1 三分

```c++
//整数三分
int l = 1,r = 100;
while(l < r) {
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    lans = f(lmid),rans = f(rmid);
    // 求凹函数的极小值
    if(lans <= rans) r = rmid - 1;
    else l = lmid + 1;
    // 求凸函数的极大值
    if(lans >= rans) l = lmid + 1;
    else r = rmid - 1;
}
// 求凹函数的极小值
cout << min(lans,rans) << endl;
// 求凸函数的极大值
cout << max(lans,rans) << endl;
```

```c++
//整数三分
int l = 1,r = 100;
while(l < r) {
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    lans = f(lmid),rans = f(rmid);
    // 求凹函数的极小值
    if(lans <= rans) r = rmid - 1;
    else l = lmid + 1;
    // 求凸函数的极大值
    if(lans >= rans) l = lmid + 1;
    else r = rmid - 1;
}
// 求凹函数的极小值
cout << min(lans,rans) << endl;
// 求凸函数的极大值
cout << max(lans,rans) << endl;
```

## 3.2 并查集

### 3.2.1 可撤销并查集

- 必须按秩合并

```c++
struct rev{
    int val;
    int fx, fy;
    int rx, ry;
};
int get(int x){
    if(fa[x] == x) return x;
    return  get(fa[x]);
}
int val;
rev merge(int x,int y){
    int fx = get(x), fy = get(y);
    rev ret = rev{
        val,
        fx, fy,
        rk[fx], rk[fy]
    };
    if(fx != fy){
      	...//val计算
        if(rk[fx] > rk[fy]) swap(fx, fy);
        fa[fx] = fy;
        rk[fy] = max(rk[fx]+1, rk[fy]);
    }
    return ret;
}
void revocation(rev node){
    val = node.val;
    fa[node.fx] = node.fx;
    fa[node.fy] = node.fy;
    rk[node.fx] = node.rx;
    rk[node.fy] = node.ry;
}
```

## 3.3 线段树

### 3.3.1 李超树

- $n$条线段，当$x=x_0$时，最大$y$是多少

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 1e6+10;
/*直线斜率，截距*/
ll k[maxn], b[maxn];
/*函数值计算*/
ll f(int cur, int x){return k[cur]*x + b[cur];} /*线段树，存直线编号*/
int T[maxn*4];
void build(int p,int l,int r,int cur)
{
    T[p] = cur;
    if(l == r) return;
    int mid = (l+r)/2;
    build(p*2,l,mid,cur);
    build(p*2+1,mid+1,r,cur);
}
void update(int p,int l,int r,int cur)
{
    int pre = T[p];
    if(l == r){
        if(f(pre, l) < f(cur, l)) T[p] = cur;
        return;
    }
    int mid = (l+r)/2;
    /*新线段斜率⾼高于原线段*/
    if(k[cur] > k[pre]){
        if(f(cur, mid) > f(pre, mid))
            T[p] = cur, update(p*2,l,mid,pre);
        else
            update(p*2+1,mid+1,r,cur);
    }
    /*新线段斜率低于原线段*/
    else{
        if(f(cur, mid) > f(pre, mid))
            T[p] = cur, update(p*2+1,mid+1,r,pre);
        else
            update(p*2,l,mid,cur);
    }
}
ll query(int p, int l, int r, int x)
{
    ll ans = f(T[p], x);
    if(l == r) return ans;
    int mid =(l+r)/2;
    if(x <= mid) ans = max(ans, query(p*2,l,mid,x));
    else ans = max(ans, query(p*2+1,mid+1,r,x));
    return ans;
}
```

