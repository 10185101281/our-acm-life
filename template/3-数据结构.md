# 数据结构

## 无旋treap（指针）beta

```c++
mt19937 rnd(233);

struct treap{
	struct Node{
		Node * l , * r;
		int val , key;
		int siz; 
		int rev;
		Node(int v = 0):l(0),r(0),key(rnd()),val(v),siz(1){}
	};	
	Node *root;
	
	void pushdown(Node* rt){
		if(!rt) return;
		if(rt->rev){ 
			swap(rt->l,rt->r);
			if(rt->l){
				rt->l->rev ^= 1;
			}
			if(rt->r){
				rt->r->rev ^= 1;
			}
			rt->rev = false;
		}
	}
	
	inline Node* newNode(int val){
		Node *ptr = new Node(val);
		return ptr;
	}
	
	inline void update(Node * now){
		if(!now) return;
		now->siz = 1;
		if(Node * u = now->l){
			now->siz += u->siz;
		}
		if(Node * u = now->r){
			now->siz += u->siz;
		}
	}
	
	int nodeSize(Node *x){ return x?x->siz:0; }
		
	void Merge(Node* &t, Node* t1 , Node *t2){
		if(!t1) return void(t = t2);
		else if(!t2) return void(t = t1);
		pushdown(t1); pushdown(t2);
		if(t1->key > t2->key){
			Merge(t1->r,t1->r,t2); 
			t = t1;
		} else {
			Merge(t2->l,t1,t2->l);
			t = t2;
		}
		update(t);
	}
	
	
	/* 按值部分 */ 
	void SplitByValue(Node * now , int val , Node* &x , Node* &y ){
		if(now == 0) return void(x = y = 0);
		else{
			pushdown(now);
			if(now->val <= val){
				SplitByValue(now->r,val,now->r,y); 
				x = now;
			} else {
				SplitByValue(now->l,val,x,now->l);
				y = now;
			}
		} 
		update(now);
	}
	
	Node* InsByValue(Node* t , int val){
		Node * p = new Node(val);
		Node *t1,*t2;
		SplitByValue(t,val,t1,t2);
		Merge(t,t1,p);
		Merge(t,t,t2);
		return t;
	}
	
	Node* DelByValue(Node * t , int val){
		Node *x,*y,*z;
		SplitByValue(t,val,x,z);
		SplitByValue(x,val-1,x,y);
		Merge(y,y->l,y->r);
		Merge(t,x,y);
		Merge(t,t,z);
		return t;
	}
	/* 按值结束	*/
	


	//按顺序部分	
	void SplitByIndex (Node* t, int i, Node* &t1, Node* &t2) {
		if(!t) return void(t1 = t2 = NULL);
		pushdown(t);
		int curr = nodeSize(t->l);
		if (i <= curr){	
			SplitByIndex(t->l, i, t1, t->l);
			t2 = t;
		}
		else{
			SplitByIndex(t->r, i - curr - 1, t->r, t2);
			t1 = t;
		}
		update(t);
	}
	
	Node* InsByIndex(Node * t , int id , int val){
		Node * p = new Node(val);
		Node *t1,*t2;
		SplitByIndex(t,val,t1,t2);
		Merge(t,t1,p);
		Merge(t,t,t2);
		return t;
	}
	
	Node* DelByIndex(Node *t , int id){
		Node *x, *y , *z;
		SplitByIndex(t,id,x,y);
		SplitByIndex(x,id-1,x,z);
		Merge(t,x,y);
		return t;
	}
	
	Node* reverse(Node *rt , int l , int r){
		Node *t1, *t2 ,*t3;
		pushdown(rt);
		SplitByIndex(rt,l-1,t1,t2);
		SplitByIndex(t2,r-l+1,t2,t3);
		t2->rev ^= 1;
		//pushdown(t1); pushdown(t2); pushdown(t3);
		Merge(t1,t1,t2);
		Merge(t1,t1,t3);
		return t1;
	}
	

	int getRank(int val){
		Node *x , *y;
		SplitByValue(root,val-1,x,y);
		int res = x? x->siz:0;
		Merge(x,x,y);		
		return res;
	}
	void traverse(Node * rt){
		if(!rt) return;
		pushdown(rt);
		traverse(rt->l);
		cout << rt->val<<' ';
		traverse(rt->r); 
	}

} tr; 
```

## 三分

```c++
//整数三分
int l = 1,r = 100;
while(l < r) {
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    lans = f(lmid),rans = f(rmid);
    // 求凹函数的极小值
    if(lans <= rans) r = rmid - 1;
    else l = lmid + 1;
    // 求凸函数的极大值
    if(lans >= rans) l = lmid + 1;
    else r = rmid - 1;
}
// 求凹函数的极小值
cout << min(lans,rans) << endl;
// 求凸函数的极大值
cout << max(lans,rans) << endl;
```

```c++
//整数三分
int l = 1,r = 100;
while(l < r) {
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    lans = f(lmid),rans = f(rmid);
    // 求凹函数的极小值
    if(lans <= rans) r = rmid - 1;
    else l = lmid + 1;
    // 求凸函数的极大值
    if(lans >= rans) l = lmid + 1;
    else r = rmid - 1;
}
// 求凹函数的极小值
cout << min(lans,rans) << endl;
// 求凸函数的极大值
cout << max(lans,rans) << endl;
```

## 并查集

### 可撤销并查集

- 必须按秩合并

```c++
struct rev{
    int val;
    int fx, fy;
    int rx, ry;
};
int get(int x){ return fa[x]==x? x: get(fa[x]);}
int val;
rev merge(int x,int y){
    int fx = get(x), fy = get(y);
    rev ret = rev{
        val,
        fx, fy,
        rk[fx], rk[fy]
    };
    if(fx != fy){
      	...//val计算
        if(rk[fx] > rk[fy]) swap(fx, fy);
        fa[fx] = fy;
        rk[fy] = max(rk[fx]+1, rk[fy]);
    }
    return ret;
}
void revocation(rev node){
    val = node.val;
    fa[node.fx] = node.fx;
    fa[node.fy] = node.fy;
    rk[node.fx] = node.rx;
    rk[node.fy] = node.ry;
}
```

## 线段树

### 李超树

- $n$条线段，当$x=x_0$时，最大$y$是多少

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 1e6+10;
/*直线斜率，截距*/
ll k[maxn], b[maxn];
/*函数值计算*/
ll f(int cur, int x){return k[cur]*x + b[cur];} /*线段树，存直线编号*/
int T[maxn*4];
void build(int p,int l,int r,int cur)
{
    T[p] = cur;
    if(l == r) return;
    int mid = (l+r)/2;
    build(p*2,l,mid,cur);
    build(p*2+1,mid+1,r,cur);
}
void update(int p,int l,int r,int cur)
{
    int pre = T[p];
    if(l == r){
        if(f(pre, l) < f(cur, l)) T[p] = cur;
        return;
    }
    int mid = (l+r)/2;
    /*新线段斜率⾼高于原线段*/
    if(k[cur] > k[pre]){
        if(f(cur, mid) > f(pre, mid))
            T[p] = cur, update(p*2,l,mid,pre);
        else
            update(p*2+1,mid+1,r,cur);
    }
    /*新线段斜率低于原线段*/
    else{
        if(f(cur, mid) > f(pre, mid))
            T[p] = cur, update(p*2+1,mid+1,r,pre);
        else
            update(p*2,l,mid,cur);
    }
}
ll query(int p, int l, int r, int x)
{
    ll ans = f(T[p], x);
    if(l == r) return ans;
    int mid =(l+r)/2;
    if(x <= mid) ans = max(ans, query(p*2,l,mid,x));
    else ans = max(ans, query(p*2+1,mid+1,r,x));
    return ans;
}
```

## 莫队

### 按奇偶性排序

- 理论上能快一倍。

```c++
bool cmp(node x,node y){
    return pos[x.l]^pos[y.l]? pos[x.l]<pos[y.l]: pos[x.l]&1? x.r<y.r: x.r>y.r;
}
```

### 带修莫队

```c++
int B;
struct AE{
    int l,r,t,id;
}ae[N];
bool cmp(AE a,AE b){
    if(a.l/B==b.l/B){
        if(a.r/B==b.r/B)return a.t<b.t;
        return a.r<b.r;
    }
    return a.l<b.l;
}
struct CE{
    int pos,pr,af;
}ce[N];
int nl, nr, nt;
void update(CE e,int p){
    int x=(p==1)? e.af: e.pr;
    ...
}
void add(int x){
    ...
}
void del(int x){
    ...
}
for(int i=1; i<=m1; i++){
    while(nt<ae[i].t) update(ce[++nt],1);
    while(nt>ae[i].t) update(ce[nt--],-1);
    while(nr<ae[i].r) add(a[++nr]);
    while(nl>ae[i].l) add(a[--nl]);
    while(nr>ae[i].r) del(a[nr--]);
    while(nl<ae[i].l) del(a[nl++]);
    ans[ae[i].id]=...
}
```

### 回滚莫队/不删除莫队

- R指针通过排序单调移动，L指针不断拉回当前块右边，再对于每个询问单调地向左移动

```c++
//求区间中相同数的最远间隔距离
for(int i=1,j=1; j<=bn; j++){
    int bd=min(n, j*B);
    int L=bd+1, R=bd, tmp=0;
    for(; blk[qry[i].l]==j; i++){
        if(blk[qry[i].r]==j) {
            ans[qry[i].id]=cal(qry[i].l,qry[i].r);
            continue;
        }
        while(R<qry[i].r) {
            ++R;
            lst[a[R]] = R;
            if(!fst[a[R]]) fst[a[R]]=R, clr.pb(a[R]);
            else tmp=max(tmp,R-fst[a[R]]);
        }
        int pre = tmp;
        while(L > qry[i].l){
            L--;
            if(lst[a[L]]) tmp=max(tmp, lst[a[L]]-L);
            else lst[a[L]]=L;
        }
        ans[qry[i].id] = tmp;
        while(L <= bd){
            if(lst[a[L]]==L) lst[a[L]]=0;
            L++;
        }
        tmp = pre;
    }
    for(auto &x: clr) fst[x]=lst[x]=0; clr.clear();
}
```

## 虚树

- 使用前按dfn排序

```c++
int s[N], top;
void insert(int x) {
    if(top==1) {s[++top] = x; return ;}
    int lca = LCA(x, s[top]);
    if(lca == s[top]) {s[++top]=x; return ;}
    while(top>1 && dfn[s[top - 1]] >= dfn[lca]) add_edge(s[top - 1], s[top]), top--;
    if(lca!=s[top]) add_edge(lca, s[top]), s[top] = lca;
    s[++top] = x;
}
```

```c++
sort(sort_vec.begin(),sort_vec.end());
top=0; s[++top]=1; for(auto &pr: sort_vec) insert(pr.sec);
top--; while(top){add_edge(s[top], s[top+1]); top--;}
```

## Bitset

​	bitset常用函数：

>`foo.size()` 返回大小（位数）
>`foo.count()` 返回1的个数
>`foo.any()` 返回是否有1
>`foo.none()` 返回是否没有1
>`foo.set()` 全都变成1
>`foo.set(p)` 将第p位变成1
>`foo.set(p, x)` 将第p位变成x
>`foo.reset()` 全都变成0
>`foo.reset(p)` 将第p位变成0
>`foo.flip()` 全都取反
>`foo.flip(p)` 将第p位取反
>`foo.to_ulong()` 返回它转换为unsigned long的结果，如果超出范围则报错
>`foo.to_ullong()` 返回它转换为unsigned long long的结果，如果超出范围则报错
>`foo.to_string()` 返回它转换为string的结果

## 高维前缀和

- 对于$i,0\le i<2^n$，求解$\sum_{j\subset i}a_i$
- 子集

```c++
rep(j,0,n-1){
    rep(i,0,(1<<n)-1){
        if((i>>j)&1) f[i] += f[i^(1<<j)];
    }
}
```

- 超集

```c++
rep(j,0,n-1){
    rep(i,0,(1<<n)-1){
        if(!((i>>j)&1)) f[i] += f[i^(1<<j)];
    }
}
```