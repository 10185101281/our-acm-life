# 3-数据结构

---

## 3.1 三分

```c++
//整数三分
int l = 1,r = 100;
while(l < r) {
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    lans = f(lmid),rans = f(rmid);
    // 求凹函数的极小值
    if(lans <= rans) r = rmid - 1;
    else l = lmid + 1;
    // 求凸函数的极大值
    if(lans >= rans) l = lmid + 1;
    else r = rmid - 1;
}
// 求凹函数的极小值
cout << min(lans,rans) << endl;
// 求凸函数的极大值
cout << max(lans,rans) << endl;
```

```c++
//整数三分
int l = 1,r = 100;
while(l < r) {
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    lans = f(lmid),rans = f(rmid);
    // 求凹函数的极小值
    if(lans <= rans) r = rmid - 1;
    else l = lmid + 1;
    // 求凸函数的极大值
    if(lans >= rans) l = lmid + 1;
    else r = rmid - 1;
}
// 求凹函数的极小值
cout << min(lans,rans) << endl;
// 求凸函数的极大值
cout << max(lans,rans) << endl;
```

## 3.2 并查集

### 3.2.1 可撤销并查集

- 必须按秩合并

```c++
struct rev{
    int val;
    int fx, fy;
    int rx, ry;
};
int get(int x){
    if(fa[x] == x) return x;
    return  get(fa[x]);
}
int val;
rev merge(int x,int y){
    int fx = get(x), fy = get(y);
    rev ret = rev{
        val,
        fx, fy,
        rk[fx], rk[fy]
    };
    if(fx != fy){
      	...//val计算
        if(rk[fx] > rk[fy]) swap(fx, fy);
        fa[fx] = fy;
        rk[fy] = max(rk[fx]+1, rk[fy]);
    }
    return ret;
}
void revocation(rev node){
    val = node.val;
    fa[node.fx] = node.fx;
    fa[node.fy] = node.fy;
    rk[node.fx] = node.rx;
    rk[node.fy] = node.ry;
}
```

