# æ•°å­¦

## æ•°è®º

### ç®€å•ç­›

- æ¬§æ‹‰ç­›
    - æ¯ä¸ªåˆæ•°åªä¼šè¢«å®ƒæœ€å°çš„è´¨å› æ•°ç­›å»

```c++
int vis[N], prime[N], num;
void euler_sieve(int n){
    memset(vis,0,sizeof(vis));
    num = 0;
    rep(i,2,n){
        if(!vis[i]) prime[++num] = i;
        rep(j,1,num){
            if(i*prime[j]>n) break;
            vis[i*prime[j]] = 1;
            if(i%prime[j]==0) break;
        }
    }
}
```

- åŒºé—´ç­›
    - ç»™å®šèŒƒå›´$[l,r],l<r\le 10^{12},r-l\le 10^6$ï¼Œé—®åŒºé—´å†…ç´ æ•°
    - å› ä¸ºrä»¥å†…åˆæ•°çš„æœ€å°è´¨å› æ•°ä¸€å®šä¸è¶…è¿‡$\sqrt r$ï¼Œç­›å‡º$\sqrt r$ä»¥å†…çš„ç´ æ•°å¹¶ç”¨è¿™äº›ç´ æ•°ç­›å‡º$[l,r]$ç´ æ•°å³å¯

```c++
int is_prime[N], is_prime_small[N];
ll prime[N]; int num;
void segment_sieve(ll l,ll r){
    for(int i=0; 1LL*i*i<=r; i++) is_prime_small[i] = 1;
    for(int i=0; i<=r-l; i++) is_prime[i] = 1;
    for(int i=2; 1LL*i*i<=r; i++){
        if(is_prime_small[i]){
            for(int j=2*i; 1LL*j*j<=r; j+=i) is_prime_small[j] = 0;
            for(ll j=max(2LL,(l+i-1)/i)*i; j<=r; j+=i) is_prime[j-l]=0;
        }
    }
    num = 0;
    for(int i=0; i<=r-l; i++){
        if(is_prime[i]) {
            if(i+l>1) prime[++num] = i+l;
        }
    }
}
```

### ç´ æ•°

- ç´ æ•°æ£€éªŒ
    - int èŒƒå›´å†…ï¼š2, 7, 61
    - long long èŒƒå›´ï¼š2, 325, 9375, 28178, 450775, 9780504, 1795265022
    - 3E15ï¼š2, 2570940, 880937, 610386380, 4130785767
    - 4E13ï¼š2, 2570940, 211991001, 3749873356

```c++
//å·²æ£€éªŒint, long longèŒƒå›´æ²¡æœ‰é—®é¢˜
bool checkQ(ll a,ll n){
    if(a>=n) return true;
    ll d = n-1;
    while(!(d&1)) d>>=1;
    ll t = pow_mod(a, d, n);
    while(d!=n-1 && t!=1 && t!=n-1){
        t = mul(t, t, n);
        d <<= 1;
    }
    return t==n-1 || d&1;
}
bool primeQ(ll n){
    if(n==2) return true;
    if(n==1 || !(n&1)) return false;
    static vector<ll> t = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    if(n <= 1) return false;
    for(auto k: t) if(!checkQ(k, n)) return false;
    return true;
}
```

- è´¨å› æ•°åˆ†è§£

```c++
//F0RE1GNERS
//åˆ†è§£åçš„æ•°å­˜å…¥facä¸­ï¼Œä¸ä¿è¯æœ‰åºï¼Œä»1å¼€å§‹
mt19937 mt(time(0));
ll pollard_rho(ll n,ll c){
    ll x = uniform_int_distribution<ll>(1, n-1)(mt), y = x;
    auto f = [&](ll v){ll t = mul(v, v, n) + c; return t < n? t: t-n;};
    while(true){
        x = f(x); y = f(f(y));
        if(x == y) return n;
        ll d = gcd(abs(x-y), n);
        if(d != 1) return d;
    }
}
ll fac[100], fcnt;
void get_fac(ll n, ll cc = 19260817) {
    if (n==4) {fac[++fcnt] = 2; fac[++fcnt] = 2; return;}
    if (primeQ(n)) {fac[++fcnt] = n; return;}
    ll p = n;
    while (p==n) p = pollard_rho(n, --cc);
    get_fac(p);
    get_fac(n / p);
}
void go_fac(ll n){ fcnt = 0; if(n>1) get_fac(n);}
```

```c++
//DCC
//é€Ÿåº¦å¯èƒ½è¾ƒå¿«
ll brent(ll n, int steps, int add) {
    if (n % 2 == 0) return 2;
    ll x = 2, y = 2, d = 1;
    while (true) {
        ll tmpx = x, tmpy = y;
        for (int i = 1; i <= steps; i++) {
            x = times(x, x, n) + add;
            if (x >= n) x -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            d = times(d, mns(x, y), n);
        }
        d = gcd(n, d);
        if (d == 1) continue;
        if (d != n) return d;
        x = tmpx, y = tmpy;
        for (int i = 1; i <= steps; i++) {
            x = times(x, x, n) + add;
            if (x >= n) x -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            d = gcd(n, mns(x, y));
            if (d != 1) return d % n;
        }
        return 0;
    }
}
ll fac[100], fcnt;
void work(ll n) {
    if (prime(n)) {
        fac[fcnt++]=n;
        return;
    }
    ll tmp = 0;
    int steps = pow(n, 0.1), add = 1;
    while (tmp == 0) tmp = brent(n, steps, add++);
    work(tmp); work(n / tmp);
}

void go_fac(ll n) {
    fcnt=0;
    work(n);
}
```

### äº’è´¨

- æ±‚é›†åˆäº’è´¨å¯¹

```c++
const int N = 1e5+10;
vector<int> d[N];
int v[N], mu[N], cnt[N];
void add(int x,int y){
    for(auto &t: d[x]){
        cnt[t] += y;
    }
}
int ask(int x){
    int ret = 0;
    for(auto &t: d[x]){
        ret += cnt[t]*mu[t];
    }
    return ret;
}
void init(int n){
    for(int i = 1; i<=n; i++){
        for(int j = 1; j<=n/i; j++){
            d[i*j].pb(i);
        }
    }
    for(int i = 1; i<=n; i++) mu[i] = 1, v[i] = 0;
    for(int i = 2; i<=n; i++){
        if(v[i]) continue;
        mu[i] = -1;
        for(int j = i*2; j<=n; j+=i){
            v[j] = 1;
            if((j/i)%i == 0) mu[j] = 0;
            else mu[j] *= -1;
        }
    }
}
```

### LCM

- næ•°ä¸­æœ€å°LCM
    - æš´åŠ›æšä¸¾çº¦æ•°iï¼Œç„¶åæš´åŠ›æšä¸¾içš„æ‰€æœ‰å€æ•°ï¼Œæ¯æ¬¡è´ªå¿ƒå–ä¸¤ä¸ªæœ€å°çš„å€æ•°ã€‚

```c++
int main(){
    cin>>n;
    int t;
    ans = 0x3f3f3f3f3f3f3f3f;
    for(int i = 1; i<=n; i++){
        scanf("%d",&t);
        if(has[t] && t < ans){
            ans = t;
            x = pos[t];
            y = i;
        }
        has[t] = 1; pos[t] = i;
    }
    for(int i = 1; i<=maxn; i++){
        int pre = 0;
        for(int j = i; j<=maxn; j+=i){
            if(has[j] == 0) continue;
            if(pre == 0){
                pre = j;
            } else {
                ll tmp = (ll)pre/gcd(pre,j)*j;
                if(tmp < ans){
                    x = pos[pre];
                    y = pos[j];
                    ans = tmp;
                }
                break;
            }
        }
    }
    if(x > y)  swap(x,y);
    cout<<x<<' '<<y;
}
```

- næ•°ä¸­æœ€å¤§LCM
    - æš´åŠ›æšä¸¾çº¦æ•°gï¼Œç„¶åä»å¤§åˆ°å°æšä¸¾å®ƒçš„å€æ•°ã€‚å¯¹äºå€æ•°xï¼Œä¸æœ€å¤§çš„å’Œå®ƒâ€œé™¤gä»¥å¤–éƒ¨åˆ†äº’è´¨â€çš„æ•°ï¼ŒåšLCMæ›´æ–°ç­”æ¡ˆã€‚
    - ç”¨ç»´æŠ¤æ ˆæŠ€å·§ä¼˜åŒ–ï¼›â€œè«æ¯”ä¹Œæ–¯+å®¹æ–¥â€æ›´æ–°å’ŒæŸ¥è¯¢ â€œå¯¹äºxï¼Œâ€˜é™¤gä»¥å¤–éƒ¨åˆ†äº’è´¨â€™çš„æ•°çš„ä¸ªæ•°â€ã€‚

````c++
const int maxn = 1e5;
int stk[maxn+10], tp = 0;
vector<int> d[maxn+10];
int miu[maxn+10], v[maxn+10];
int cnt[maxn+10];
int has[maxn+10];
void add(int x,int y){
    for(auto &t: d[x]){
        cnt[t] += y;
    }
}
int ask(int x){
    int ret = 0;
    for(auto &t: d[x]){
        ret += cnt[t]*miu[t];
    }
    return ret;
}
int gcd(int a,int b){
    return b? gcd(b,a%b): a;
}
void init(){
    for(int i = 1; i<=maxn; i++){
        for(int j = 1; j<=maxn/i; j++){
            d[i*j].pb(i);
        }
    }
    for(int i = 1; i<=maxn; i++) miu[i] = 1, v[i] = 0;
    for(int i = 2; i<=maxn; i++){
        if(v[i]) continue;
        miu[i] = -1;
        for(int j = i*2; j<=maxn; j+=i){
            v[j] = 1;
            if((j/i)%i == 0) miu[j] = 0;
            else miu[j] *= -1;
        }
    }
}
int main(){
    init();
    int n; cin>>n;
    ll ans = 0;
    for(int i = 1; i<=n; i++){
        int x; scanf("%d",&x);
        if(has[x]) ans = max(ans, (ll)x);
        has[x] = 1;
    }
    for(int g = 1; g<=maxn; g++){
        for(int x = maxn/g; x>=1; --x){
            if(!has[x*g]) continue;
            int c = ask(x);
            while(c){
                int y = stk[tp--];
                if(gcd(x,y) == 1) c--;
                if(c == 0) ans = max(ans, 1LL*x*y*g);
                add(y,-1);
            }
            add(x,1);
            stk[++tp] = x;
        }
        while(tp) add(stk[tp--],-1);
    }
    cout<<ans<<endl;
}
````

### è«æ¯”ä¹Œæ–¯åæ¼”/æ•°è®ºå‰ç¼€å’Œ

#### å¸¸ç”¨å‡½æ•°ä¸å…¬å¼

- å‡½æ•°
    - $\varphi(n)$ï¼šæ¬§æ‹‰å‡½æ•°
    - $\mu(n) = \begin{cases} 1 &n=1 \\ (-1)^k & n=p_1p_2...p_k \\\ 0 & other \end{cases}$ï¼šè«æ¯”ä¹Œæ–¯å‡½æ•°
    - $1(n)=1$
    - $id(n)=n$
    - $\sigma(n)$ï¼šnçš„çº¦æ•°ä¸ªæ•°
    - $d(n)$ï¼šnçš„çº¦æ•°çš„å’Œ
    - $\varepsilon(n)=[n=1]$
- ç‹„åˆ©å…‹é›·å·ç§¯å¸¸ç”¨å…¬å¼
    - $\varphi * 1 = id$
    - $\mu * 1 = \varepsilon$
    - $\mu * id = \varphi$
- è«æ¯”ä¹Œæ–¯åæ¼”
    - å½¢å¼ä¸€ï¼š$F(n)=\sum _{d\mid n}f(d)\rightarrow f(n)=\sum_{d\mid n}\mu(d)F(\frac{n}{d})$
    - å½¢å¼äºŒï¼š$F(n)=\sum_{n\mid d}f(d)\rightarrow f(n)=\sum_{n\mid d}\mu (\frac{d}{n})F(d)$

#### ç»å…¸æ¨å¯¼

- $\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=1]$

â€‹	$\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=1]$

  =$\sum _{i=1}^n\sum _{j=1}^n\sum _{d\mid gcd(i,j)}\mu(d)$

  =$\sum_{i=1}^n\sum_{j=1}^n\sum_{d|i,d|j}\mu(d)$

  =$\sum_{d=1}^n\mu(d)\sum_{d\mid i}\sum_{d\mid j }1$

  =$\sum_{d=1}^n\mu(d)\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor n/d\rfloor}1$

  =$\sum_{d=1}^n\mu(d)\lfloor \frac{n}{d}\rfloor ^2$



- $\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=k]$

â€‹	$\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=k]$

  =$\sum_{i=1}^n\sum_{j=1}^n\sum_{d\mid gcd(\frac{i}{k},\frac{j}{k})}\mu(d)$

  =$\sum_{i=1}^n\sum_{j=1}^n\sum_{d|\frac{i}{k},d|\frac{j}{k}}\mu(d)$

  =$\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\sum_{dk\mid i}\sum_{dk\mid j }1$

  =$\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\sum_{i=1}^{\lfloor n/dk\rfloor}\sum_{j=1}^{\lfloor n/dk\rfloor}1$

  =$\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\lfloor \frac{n}{dk}\rfloor ^2$



- $\sum_{i=1}^n [gcd(i,x)=k]$

  $\sum_{i=1}^n [gcd(i,x)=k]$

=$\sum_{i=1}^n\sum_{d\mid \frac{i}{k},d\mid \frac{x}{k}}\mu(d)$

=$\sum_{d\mid \frac{x}{k}}\mu (d)\sum_{i=1}^{\lfloor n/dk\rfloor} 1$

=$\sum_{d\mid \frac{x}{k}}\mu(d)\lfloor \frac{n}{dk}\rfloor$



- $\sum_{i=1}^n\sum_{j=1}^ngcd(i,j)$

â€‹	$\sum_{i=1}^n\sum_{j=1}^mgcd(i,j)$

=$\sum_{k=1}^n\sum_{i=1}^n\sum_{j=1}^nk[gcd(i,j)=k]$

=$\sum_{k=1}^nk\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=k]$

=$\sum_{k=1}^nk\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\lfloor \frac{n}{dk}\rfloor ^2$

â€‹	ä»¤$T=dk$

=$\sum_{k=1}^n\sum_{d=1}^{\lfloor n/k\rfloor}k\mu(d)\lfloor \frac{n}{dk}\rfloor ^2$

=$\sum_{T=1}^n\sum_{d\mid T} (\frac{T}{d})\mu(d)\lfloor \frac{n}{T}\rfloor ^2$

=$\sum_{T=1}^n \lfloor\frac{n}{T}\rfloor^2 \sum_{d\mid T}(\frac{T}{d})\mu(d)$

=$\sum_{T=1}^n \lfloor\frac{n}{T}\rfloor^2 \varphi(T)$



- $\sum_{i=1}^n\sum_{j=1}^nlcm(i,j)$

â€‹	$\sum_{i=1}^n\sum_{j=1}^nlcm(i,j)$

  =$\sum_{i=1}^n\sum_{j=1}^n\frac{ij}{gcd(i,j)}$

  =$\sum_{k=1}^{n}\sum_{i=1}^n\sum_{j=1}^n\frac{ij}{k[gcd(i,j)=k]}$

  =$\sum_{k=1}^{n}\sum_{i=1}^{\lfloor n/k\rfloor}\sum_{j=1}^{\lfloor n/k\rfloor}\frac{ikjk}{k}{[gcd(i,j)=1]}$

  =$\sum_{k=1}^{n}k\sum_{i=1}^{\lfloor n/k\rfloor}\sum_{j=1}^{\lfloor n/k\rfloor}ij{[gcd(i,j)=1]}$

  =$\sum_{k=1}^{n}k\sum_{i=1}^{\lfloor n/k\rfloor}\sum_{j=1}^{\lfloor n/k\rfloor}ij\sum_{d|i,d|j}\mu(t)$

  =$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\sum_{i=1}^{\lfloor n/dk\rfloor}\sum_{j=1}^{\lfloor n/dk\rfloor}idjd$

  =$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)d^2\sum_{i=1}^{\lfloor n/dk\rfloor}\sum_{j=1}^{\lfloor n/dk\rfloor}ij$

  =$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)d^2\sum_{i=1}^{\lfloor n/dk\rfloor}i\sum_{j=1}^{\lfloor n/dk\rfloor}j$

â€‹	è®°$sum(n)=1+2+...+n=\frac{n(n+1)}{2}$

  =$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)d^2sum(\lfloor n/dk\rfloor)^2$



- $\sum_{{a_1}=1}^n\sum_{{a_2}=1}^n...\sum_{{a_x}=1}^n(\Pi_{j=1}^xa_j^k)f(gcd(a_1,a_2,...,a_x))Â·gcd(a_1,a_2,...,a_x)$
- å…¶ä¸­$f(x)$å®šä¹‰ä¸ºï¼šå¦‚æœå­˜åœ¨æ•´æ•°$t(t>1)$ä½¿å¾—$t^2$æ˜¯$x$çš„å› å­ï¼Œé‚£ä¹ˆ$f(x)=0$ï¼Œå¦åˆ™$f(x)=1$ã€‚

$\sum_{{a_1}=1}^n\sum_{{a_2}=1}^n...\sum_{{a_x}=1}^n(\Pi_{j=1}^xa_j^k)f(gcd(a_1,a_2,...,a_x))Â·gcd(a_1,a_2,...,a_x)$

 =$\sum_{d=1}^ndf(d)\sum_{{a_1}=1}^n\sum_{{a_2}=1}^n...\sum_{{a_x}=1}^n(\Pi_{j=1}^xa_j^k)[gcd(a_1,a_2,...,a_n)=d]$

 =$\sum_{d=1}^nd^{kx+1}f(d)\sum_{{a_1}=1}^{\lfloor n/d\rfloor}\sum_{{a_2}=1}^{\lfloor n/d\rfloor}...\sum_{{a_x}=1}^{\lfloor n/d\rfloor}(\Pi_{j=1}^xa_j^k)[gcd(a_1,a_2,...,a_n)=1]$

â€‹	æ ¹æ®$\mu *I = d$ï¼Œæœ‰

 =$\sum_{d=1}^nd^{kx+1}f(d)\sum_{{a_1}=1}^{\lfloor n/d\rfloor}\sum_{{a_2}=1}^{\lfloor n/d\rfloor}...\sum_{{a_x}=1}^{\lfloor n/d\rfloor}(\Pi_{j=1}^xa_j^k)\sum_{t\mid a_1,t\mid a_2,...,t\mid a_x}\mu(t)$

 =$\sum_{d=1}^nd(td)^{kx}f(d)\sum_{t=1}^{\lfloor n/d\rfloor}\mu(t)\sum_{{a_1}=1}^{\lfloor n/dt\rfloor}\sum_{{a_2}=1}^{\lfloor n/dt\rfloor}...\sum_{{a_x}=1}^{\lfloor n/dt\rfloor}(\Pi_{j=1}^xa_j^k)$

 =$\sum_{d=1}^nd(td)^{kx}f(d)\sum_{t=1}^{\lfloor n/d\rfloor}\mu(t)\sum_{{a_1}=1}^{\lfloor n/dt\rfloor}a_1^k\sum_{{a_2}=1}^{\lfloor n/dt\rfloor}a_2^k...\sum_{{a_x}=1}^{\lfloor n/dt\rfloor}a_x^k$

 =$\sum_{d=1}^nd(td)^{kx}f(d)\sum_{t=1}^{\lfloor n/d\rfloor}\mu(t)(\sum_{i=1}^{\lfloor n/dt\rfloor}i^k)^x$

â€‹	ä»¤$T=dt$

 =$\sum_{d=1}^n\sum_{t=1}^{\lfloor n/d\rfloor}d(td)^{kx}f(d)\mu(t)(\sum_{i=1}^{\lfloor n/dt\rfloor}i^k)^x$

 =$\sum_{T=1}^n\sum_{d|T}d(T)^{kx}f(d)\mu(\frac{T}{d})(\sum_{i=1}^{\lfloor n/T\rfloor}i^k)^x$

 =$\sum_{T=1}^n(T)^{kx}(\sum_{i=1}^{\lfloor n/T\rfloor}i^k)^x\sum_{d|T}df(d)\mu(\frac{T}{d})$

â€‹	æ³¨æ„åˆ°$f(x)=|\mu(x)|$ï¼Œç”±äº$\mu(x)=0,1,-1$ï¼Œæ‰€ä»¥äº¦å¯ä»¥å†™ä½œ$f(x)=\mu(x)^2$ï¼ˆæ–¹ä¾¿è®¡ç®—ï¼‰ã€‚

 =$\sum_{T=1}^n(T)^{kx}(\sum_{i=1}^{\lfloor n/T\rfloor}i^k)^x\sum_{d|T}d\mu(d)^2\mu(\frac{T}{d})$  

â€‹	ä»¤$g(T)=\sum_{d|T}d\mu(d)^2\mu(\frac{T}{d}),s(T)=\sum_{i=1}^{T}i^k$

 =$\sum_{T=1}^ns(\lfloor n/T\rfloor)^x(T)^{kx}g(T)$  

â€‹	é¢„å¤„ç†$s(T),g(T)$å¹¶é¢„å¤„ç†$(T)^{kx}g(T)$çš„å‰ç¼€å’Œï¼Œé‚£ä¹ˆå¯¹äºæ¯ä¸ªnå°±å¯ä»¥ç”¨æ•°è®ºåˆ†å—$O(\sqrt n)$çš„å›ç­”ã€‚

#### ä¾‹é¢˜

- ç»™ n ä¸ªæ•°ï¼Œé—®èƒ½æ‰¾å‡ºå¤šå°‘ä¸ªä¸åŒçš„å››å…ƒç»„(a,b,c,d)ä½¿å¾— gcd(a,b,c,d) = 1ã€‚

è®¾$F(x)$ï¼šæœ‰å¤šå°‘å››å…ƒç»„$(a,b,c,d)$æ»¡è¶³$x\mid gcd(a,b,c,d)$

è®¾$f(x)$ï¼šæœ‰å¤šå°‘å››å…ƒç¥–$(a,b,c,d)$æ»¡è¶³$x=gcd(a,b,c,d)$

é—®é¢˜å³æ±‚è§£$f(1)=\sum \mu (x)F(x)$ã€‚

è®°èƒ½è¢«$x$æ•´é™¤çš„æ•°æœ‰$c_x$ä¸ªï¼Œåˆ™$F(x) = C(c_x,4)$ã€‚

- ç»™ä¸€ä¸ªnï¼Œæ¯æ¬¡åœ¨$[1,n]$ä¸­éšæœºå–ä¸€ä¸ªæ•°æ”¾åˆ°å®¹å™¨ä¸­ï¼Œå½“å®¹å™¨ä¸­æ•°çš„$gcd$ä¸º1æ—¶åœæ­¢ï¼Œæ±‚æœŸæœ›æ­¥æ•°

åšæ³•ä¸€ï¼š

â€‹	è®¾$f(x)$ï¼Œè¡¨ç¤ºå½“å‰$gcd$ä¸º$x$ï¼Œè½¬åˆ°$gcd$ä¸º1çš„æœŸæœ›æ­¥æ•°

â€‹	æœ‰$f(x)=1+\sum_{y\mid x}\frac{f(y)\times cnt_y}{m}$ï¼Œ$cnt_y =\sum_{i=1}^n [gcd(i,x)=y]$

â€‹	$ans = 1+\sum_{i=1}^n\frac{f(i)}{n} $

åšæ³•äºŒï¼š

â€‹	å®šä¹‰$F(i)$ï¼Œè¡¨ç¤º$i\mid gcd$çš„æ‰€æœ‰åºåˆ—çš„æœŸæœ›é•¿åº¦

â€‹	å®šä¹‰$p(i)$ï¼Œè¡¨ç¤ºéšæœºå–ä¸€ä¸ªæ•°$x$ï¼Œæ»¡è¶³$i\mid x$çš„æ¦‚ç‡ï¼Œå³$\frac{\lfloor n/i\rfloor}{n}$

â€‹	åˆ™$F(i)=\sum p(i)^j = \frac{p(i)}{1-p(i)}=\frac{\lfloor n/i\rfloor}{n-\lfloor n/i\rfloor}$

â€‹	ç”±å®¹æ–¥ï¼Œå¾—

â€‹	$ans = 1+\sum_{d=2}^n-\mu(d)F(d)$

### æœæ•™ç­›

#### æ€è·¯

â€‹	éœ€è¦æ±‚è§£$\sum_{i=1}^nf(i)$ï¼Œå…¶ä¸­$f(i)$ä¸ºç§¯æ€§å‡½æ•°ã€‚

â€‹	æ„é€ ä¸¤ä¸ªç§¯æ€§å‡½æ•°$h=f * g$

â€‹	è®°$S(n) = \sum_{i=1}^nf(i)$
$$
\sum _{i=1}^n h(i) = \sum _{i=1}^n\sum_{d\mid i}g(d)f(\frac{i}{d})\\
\Rightarrow \sum _{i=1}^n h(i) = \sum _{d=1}^ng(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}f(i)\\
\Rightarrow \sum_{i=1}^nh(i)=\sum_{d=1}^ng(d)S(\lfloor \frac{n}{d}\rfloor)\\
\Rightarrow \sum_{i=1}^nh(i)=g(1)S(n)+\sum_{d=2}^ng(d)S(\lfloor \frac{n}{d}\rfloor)\\
\Rightarrow g(1)S(n) = \sum_{i=1}^nh(i) - \sum_{d=2}^ng(d)S(\lfloor \frac{n}{d}\rfloor)
$$

#### ç»å…¸æ¨å¯¼

- $S(n)=\sum_{i=1}^n \mu(i)$

â€‹	æ„é€ $\varepsilon = \mu * 1$

â€‹	$S(n) = 1 - \sum_{d=2}^nS(\lfloor \frac{n}{d}\rfloor)$

- $S(n)=\sum_{i=1}^n\varphi(i)$

â€‹	æ„é€ $id = \varphi * 1$

â€‹	$S(n) = \sum_{i=1}^ni-\sum _{d=2}^nS(\lfloor \frac{n}{d}\rfloor)$

- $S(n)=\sum_{i=1}^ni\varphi(i)$

â€‹	æ„é€ $n^2 = id*(i\varphi(i))$

â€‹	$S(n)=\sum_{i=1}^ni^2-\sum_{d=2}^ndS(\lfloor \frac{n}{d}\rfloor)$

### ç±»æ¬§

- å‡»é¼“ä¼ èŠ±

é¢˜æ„ï¼š

â€‹	æœ‰$n$ä¸ªäººå›´æˆä¸€ä¸ªç¯ï¼Œä»ç¬¬$s$äººå¼€å§‹ä¼ èŠ±ï¼Œæ¯ä¸ªäººå°†èŠ±ä¼ ç»™å‘åæ•°ç¬¬$x$ä¸ªäººã€‚å¯¹ä¼ èŠ±çš„äººè¿›è¡Œç¼–å·ï¼ˆä»0å¼€å§‹ï¼Œ0,1,2,...ï¼‰ï¼Œé—®åœ¨åŒºé—´$[l,r]$çš„äººç¬¬ä¸€æ¬¡è¢«ç¼–å·çš„å·ç ï¼ˆå¦‚æœå§‹ç»ˆä¸ä¼šè¢«ç¼–å·ï¼Œåˆ™è¾“å‡º-1ï¼‰ã€‚

â€‹	ç”±äºå›´æˆä¸€ä¸ªç¯ï¼Œå¦‚æœ$l\le r$ï¼Œåˆ™è¡¨ç¤ºåŒºé—´$[l,r]$ï¼Œå¦åˆ™è¡¨ç¤º$[r,n-1]$å’Œ$[0,l]$ã€‚

â€‹	$T\le 10^5, 2\le n\le 10^9, 1\le x\le 10^9, 0\le s,l,r\le n-1$ã€‚

æ€è·¯ï¼š

â€‹	é¦–å…ˆï¼Œé—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºä»0å¼€å§‹ï¼Œç¯çš„é•¿åº¦ä¸º$b$ï¼Œæ¯æ¬¡è·³$a$æ­¥ï¼Œç¬¬ä¸€æ¬¡è·³åˆ°åŒºé—´$[l,r],l\le r$æ‰€ç”¨æ¬¡æ•°ã€‚

â€‹	å³æ±‚è§£æœ€å°çš„è‡ªç„¶æ•°$x$ï¼Œæ»¡è¶³$l\le ax\ mod\ b\le r$ï¼Œè®°ä¸º$f(a,b,l,r)$ã€‚

â€‹	åˆ†æƒ…å†µè®¨è®ºï¼š

â€‹	ï¼ˆ1ï¼‰è‹¥$\lceil \frac{l}{a}\rceil \le \lfloor \frac{r}{a}\rfloor $ï¼Œ

â€‹		åˆ™$f(a,b,l,r)=\lceil \frac{l}{a}\rceil $

â€‹	ï¼ˆ2ï¼‰å¦åˆ™ï¼Œ

â€‹		å­˜åœ¨$M\in N^*$ï¼Œä½¿å¾—$aM<l\le r< a(M+1)$ã€‚

â€‹		$aM<l\le ax-bk\le r<a(M+1)$

â€‹	$\Rightarrow -a(M+1)<-r\le bk-ax\le -l< -aM$

â€‹	$\Rightarrow a(x-M-1)<-r+ax\le bk\le -l+ax<a(x-M)$

â€‹		è€Œ$k$å³ä¸º$f(b\ mod\ a ,a,(-r)\ mod\ a, (-l)\ mod\ a)$ã€‚

â€‹		é€’å½’æ±‚è§£å³å¯ã€‚

â€‹		æ³¨æ„åˆ¤æ–­æ— è§£çš„æƒ…å†µï¼š

â€‹	ï¼ˆ1ï¼‰$a=0$ï¼šä¸Šä¸€å±‚æ²¡æœ‰å¾—åˆ°ç­”æ¡ˆï¼Œæ‰€ä»¥å¿…æœ‰$0\not\in [l,r]$ï¼Œæ‰€ä»¥æ— è§£ã€‚

â€‹	ï¼ˆ2ï¼‰$l>r$ï¼šä¸Šä¸€å±‚çš„ä¸ç­‰å¼å¿…ç„¶æ— è§£ã€‚

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll inf = 1e18;
inline ll tsf(ll x,ll mod){return (x%mod+mod)%mod;}
ll f(ll a, ll b, ll l, ll r){
    if(!a || l>r) return inf;
    ll t1 = (l+a-1)/a, t2 = r/a;
    if(t1 <= t2) return t1;
    ll k = f(tsf(b,a), a, tsf(-r,a), tsf(-l,a));
    if(k == inf) return inf;
    return (l+k*b + a-1)/a;
}
int main(){
     int T; cin>>T;
     while(T--){
         ll x, n, s, l, r;
         scanf("%lld%lld%lld%lld%lld",&x,&n,&s,&l,&r);
         l =tsf(l-s, n), r=tsf(r-s, n);
         ll ans = (l>r)? min(f(x,n,l,n-1),f(x,n,0,r)): f(x,n,l,r);
         if(ans == inf) puts("-1");
         else printf("%lld\n",ans);
     }
     return 0;
}
```

## é«˜æ•°

### å·ç§¯

- FFT

```c++
const double PI = acos(-1);
struct C{
    double r, i;
    C(double r = 0, double i = 0): r(r), i(i){}
};
C operator + (const C&a, const C&b){
    return C(a.r+b.r, a.i+b.i);
}
C operator - (const C&a, const C&b){
    return C(a.r-b.r, a.i-b.i);
}
C operator * (const C&a, const C&b){
    return C(a.r*b.r-a.i*b.i, a.r*b.i + a.i*b.r);
}
void FFT(C x[], int n, int p) {
    for (int i = 0, t = 0; i < n; ++i) {
        if (i > t) swap(x[i], x[t]);
        for (int j = n >> 1; (t ^= j) < j; j >>= 1);
    }
    for (int h = 2; h <= n; h <<= 1) {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i < n; i += h) {
            C w(1, 0), u;
            for (int j = i, k = h >> 1; j < i + k; ++j) {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1){
        for(int i = 0; i<=n; i++) x[i].r /= n;
    }
}

void conv(C a[], C b[], int n) {
    FFT(a, n, 1);
    FFT(b, n, 1);
    for(int i = 0; i<=n; i++){
        a[i] = a[i] * b[i];
    }
    FFT(a, n, -1);
}
```

- NTT

NTTç´ æ•°è¡¨åŠå…¶å¯¹åº”åŸæ ¹

| MOD        | G    |
| ---------- | ---- |
| 40961      | 3    |
| 65537      | 3    |
| 786433     | 10   |
| 5767169    | 3    |
| 7340033    | 3    |
| 23068673   | 3    |
| 104857601  | 3    |
| 167772161  | 3    |
| 469762049  | 3    |
| 998244353  | 3    |
| 1004535809 | 3    |

| MOD         | G    |
| ----------- | ---- |
| 2013265921  | 31   |
| 2281701377  | 3    |
| 3221225473  | 5    |
| 75161927681 | 3    |

```c++
//Gä¸ºåŸæ ¹
const int N = 2e5+10;
const int G = 3;
int wn[N<<4], rev[N<<4];
int NTT_init(int pn){
    int step=0; int n = 1;
    for(; n<pn; n<<=1) ++step;
    for(int i=1; i<n; i++) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(step-1));
    int g = qpow(G,(mod-1)/n);
    wn[0] = 1;
    for(int i=1; i<=n; i++) wn[i] = mul(wn[i-1], g);
    return n;
}
void NTT(int a[],int n,int f){
    for(int i=0; i<n; i++){
        if(i<rev[i]) swap(a[i], a[rev[i]]);
    }
    for(int k=1; k<n; k<<=1){
        for(int i=0; i<n; i+=(k<<1)){
            int t = n/(k<<1);
            for(int j=0; j<k; j++){
                int w = (f==1)? wn[t*j]: wn[n-t*j];
                int x = a[i+j];
                int y = mul(a[i+j+k], w);
                a[i+j] = add(x, y);
                a[i+j+k] = sub(x, y);
            }
        }
    }
    if(f == -1){
        int ninv = qpow(n, mod-2);
        for(int i=0; i<n; i++) a[i] = mul(a[i], ninv);
    }
}
```

- åˆ†æ²»NTT
    - ä¾‹é¢˜ï¼šç»™å®šåºåˆ—$g_{1...n-1}$ï¼Œæ±‚åºåˆ—$f_{0...n-1}$ã€‚å…¶ä¸­$f_i=\sum_{j=1}^if_{i-j}g_j,f_0=1$ã€‚

```c++
#include <bits/stdc++.h>
using namespace std;

const int mod = 998244353;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){...}

const int N = 2e5+10;
const int G = 3;
int wn[N<<4], rev[N<<4];
// mod 998244353,1004535809,469762049
int NTT_init(int pn){...}
void NTT(int a[],int n,int f){...}

int f[N], g[N];
int a[N<<4], b[N<<4];
int n;
void solve(int l,int r,int len){
    if(l >= n) return ;
    if(len == 1) return ;
    int tlen = len>>1;
    int mid = (l+r)>>1;
    solve(l,mid,tlen);
    NTT_init(len);
    for(int i=0; i<len; i++) a[i] = b[i] = 0;
    for(int i=0; i<tlen; i++) a[i] = f[i+l];
    for(int i=0; i<len; i++) b[i] = g[i];
    NTT(a,len,1); NTT(b,len,1);
    for(int i=0; i<len; i++) a[i] = mul(a[i],b[i]);
    NTT(a,len,-1);
    for(int i=tlen; i<len; i++) f[i+l] = add(f[i+l], a[i]);
    solve(mid,r,tlen);
}
int main(){
    cin>>n;
    int tn = 1; while(tn<n) tn<<=1;
    for(int i=0; i<tn; i++) g[i] = 0;
    for(int i=1; i<n; i++) scanf("%d",g+i);
    for(int i=0; i<tn; i++) f[i] = 0; f[0] = 1;
    solve(0, tn, tn);
    for(int i=0; i<n; i++) printf("%d%c",f[i]," \n"[i==n]);
    return 0;
}
```

#### ç»å…¸é—®é¢˜

- Residual Polynomial

é¢˜æ„ï¼š

â€‹	ç»™å®šå¤šé¡¹å¼$f_1(x)=\sum_{i=0} ^n a_ix^i$ä¸åºåˆ—$\{b_n\},\{c_n\}$ã€‚

â€‹	å·²çŸ¥é€’æ¨å¼$f_n=b_nf'_{n-1}+c_nf_{n-1}(n>1)$ï¼Œæ±‚$f_n$ã€‚

â€‹	$3\le n\le 10^5, 0\le a_i,b_i,c_i<998244353, mod\ 998244353$

æ€è·¯ï¼š

â€‹	
$$
f_{1,0}\qquad f_{2,0}\qquad f_{3,0}\qquad \cdots \qquad f_{n,0}\\
f_{1,1}\qquad f_{2,1}\qquad f_{3,1}\qquad \cdots \qquad f_{n,1}\\
\vdots \ \ \ \ \ \qquad\vdots\ \ \ \ \  \qquad \vdots \qquad \ddots \qquad\ \  \vdots \\
f_{1,n}\qquad f_{2,n}\qquad f_{3,n}\qquad \cdots \qquad f_{n,n}
$$

â€‹	å¯¹äº$f_{i,j}$å­˜åœ¨ä¸¤ç§è½¬ç§»ï¼š
$$
	\begin{cases}
	f_{i,j}\overset{c_{i+1}}{\rightarrow} f_{i+1,j}&i<n\\
	
	f_{i,j}\overset{jÂ·b_{i+1}}\rightarrow f_{i+1,j}&i<n,j>0
	\end{cases}
$$
â€‹	é‚£ä¹ˆ$f_{1,i}$å¯¹$f_{n,j}$çš„è´¡çŒ®ä¸º$f_{1,i}Â·\sum(\Pi pathvalue)$ï¼Œå³$f_{1,i}$åˆ°$f_{n,j}$æ‰€æœ‰å¯è¡Œè·¯å¾„è¾¹æƒä¹˜ç§¯å’Œã€‚

â€‹	å…ˆä¸è€ƒè™‘ç¬¬äºŒç±»è½¬ç§»ä¸­$ğ‘—â‹…ğ‘ğ‘–+1$çš„$j$ï¼Œå¯¹äºä»»ä½•è½¬ç§»$f_{1,i}\rightarrow f_{n,j}$ï¼Œå®é™…æ˜¯å¯¹äºæ¯ä¸ª$2\le k\le n$ï¼Œé€‰æ‹©$b_k$æˆ–$c_k$ï¼Œå…¶ä¸­$b_k$é€‰æ‹©$iâˆ’j$ä¸ªï¼Œ$c_k$é€‰æ‹©$nâˆ’1âˆ’(iâˆ’j)$ä¸ªï¼Œä¹˜èµ·æ¥ç„¶åå†æŠŠæ‰€æœ‰æ–¹æ¡ˆåŠ èµ·æ¥ã€‚

â€‹	ä»¤é€‰æ‹©$x$ä¸ª$b_x$å’Œ$n-1-x$ä¸ª$c_k$æ‰€æœ‰æ–¹æ¡ˆå’Œä¸º$F(x)$ï¼Œ$F(x)$å¯ä»¥ç”±åˆ†æ²»+FFTå¾—åˆ°ï¼š

â€‹		ä»¤$F(l,r,x)$è¡¨ç¤ºåœ¨åŒºé—´$[l,r)$ä¸­é€‰æ‹©$x$ä¸ª$b_k$çš„æ‰€æœ‰æ–¹æ¡ˆçš„å’Œï¼Œé‚£ä¹ˆæœ‰$F(l,r,x)=\sum_{i+j=x}F(l,mid,i)Â·F(mid,r,j)$ï¼Œå…¶ä¸­$mid =\lfloor \frac{l+r}{2}\rfloor$ã€‚

â€‹	å†ç®—ä¸Šä¹‹å‰æ²¡è€ƒè™‘çš„$j$çš„è´¡çŒ®ä¹˜ç§¯ï¼Œå¯ä»¥å¾—åˆ°$f_{n,j}=\sum_{i-j=k}F(k)Â·f_{1,i}Â·\frac{i!}{j!}$ï¼Œ

â€‹	å°†æ•°ç»„åè½¬ï¼Œå³$f_{i,j}$ä¸$f_{i,n-j}$äº’æ¢ï¼Œé‚£ä¹ˆæœ‰$f_{n,j}=\sum_{i+j=k}F(k)Â·f_{1,i}Â·\frac{(n-i)!}{(n-j)!}$

```c++
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){...}
const int N = 2e5+10;
int fac[N], inv[N], ifac[N];
inline void init(int n){
    fac[0] = ifac[0] = inv[1] = 1;
    for(int i=1; i<=n; i++) fac[i] = mul(fac[i-1], i);
    for(int i=2; i<=n; i++) inv[i] = mul(sub(mod,mod/i),inv[mod%i]);
    for(int i=1; i<=n; i++) ifac[i] = mul(ifac[i-1], inv[i]);
}

const int G = 3;
int wn[N<<4], rev[N<<4];
// mod 998244353,1004535809,469762049
int NTT_init(int pn){...}
void NTT(int a[],int n,int f){...}

int F[N<<2], a[N<<2], b[N<<2], c[N<<2], ans[N<<2];
void cal_F(int F[],int l,int r){
    if(l+1 == r){
        F[0] = c[l];
        F[1] = b[l];
        return ;
    }
    int mid = (l+r)>>1;
    int len = r-l+1;
    int lf[len<<2], rf[len<<2];
    memset(lf, 0, sizeof(lf));
    memset(rf, 0, sizeof(rf));
    cal_F(lf,l,mid);
    cal_F(rf,mid,r);
    int tn = 1; while(tn < len) tn<<=1;
    NTT_init(tn);
    NTT(lf,tn,1); NTT(rf,tn,1);
    for(int i=0; i<tn; i++) F[i] = mul(lf[i],rf[i]);
    NTT(F,tn,-1);
    for(int i=len; i<tn; i++) F[i] = 0;
}

int main(){
    init(N-1);
    int T; cin>>T;
    while(T--){
        int n; scanf("%d",&n);
        for(int i=0; i<n+1; i++) scanf("%d",a+i);
        for(int i=0; i<n-1; i++) scanf("%d",b+i);
        for(int i=0; i<n-1; i++) scanf("%d",c+i);
        int len = 1; while(len<n) len<<=1;
        cal_F(F,0,n-1);

        while(len<=n+1) len<<=1; len<<=1;
        reverse(a,a+n+1);
        for(int i=0; i<n+1; i++) a[i] = mul(a[i],fac[n-i]);
        for(int i=n; i<len; i++) F[i] = 0;
        for(int i=n+1; i<len; i++) a[i] = 0;
        NTT_init(len);
        NTT(a,len,1); NTT(F,len,1);
        for(int i=0; i<len; i++) ans[i] = mul(a[i], F[i]);
        NTT(ans,len,-1);
        for(int i=0; i<n+1; i++) ans[i] = mul(ans[i],ifac[n-i]);
        reverse(ans,ans+n+1);
        for(int i=0; i<n+1; i++) printf("%d%c",ans[i]," \n"[i==n]);
    }
    return 0;
}
```

- Expected area

é¢˜æ„ï¼š

â€‹	ç»™å‡ºä¸¤ä¸ªåŒºé—´é›†åˆ$S=\{(l_1,r_1),...,(l_n,r_n)\},T=\{(s_1,t_1),...,(s_n,t_n)\}$ã€‚

â€‹	è®¡ç®—$\bigcup_{i=1}^n([l_i,r_i]\times [s_{p(i)},t_{p(i)}])$çš„æœŸæœ›é¢ç§¯ã€‚$p$æ˜¯ç­‰æ¦‚ç‡éšæœºæ’åˆ—ã€‚

â€‹	$2\le n\le 2\times 10^5,0\le l_i<r_i< 998244353,0\le s_i<t_i<998244353$

â€‹	ç»“æœæ¨¡$998244353$

æ€è·¯ï¼š

â€‹	å¯¹ä¸€å—åŒºåŸŸï¼Œè€ƒè™‘è®¡ç®—å®ƒä¸è¢«è¦†ç›–çš„æ¦‚ç‡$p$ï¼Œé‚£ä¹ˆå®ƒå¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯$(1-p)\times S$ã€‚

â€‹	å‡è®¾è¯¥åŒºåŸŸxè½´è¦†ç›–$i$æ¬¡ï¼Œ$y$è½´è¦†ç›–$j$æ¬¡ï¼Œé‚£ä¹ˆè¯¥åŒºåŸŸä¸è¢«è¦†ç›–ï¼Œå½“ä¸”ä»…å½“è¿™ä¸ªiä¸ªxåŒºé—´ä¸jä¸ªyåŒºé—´ä¸é…å¯¹ï¼Œé‚£ä¹ˆ$p=\frac{C_{n-i}^jA_j^jA_{n-j}^{n-j}}{A_n^n}=\frac{A_{n-i}^{n-i}A_j^jA_{n-j}^{n-j}}{A_n^nA_{j}^{j}A_{n-i-j}^{n-i-jj}}=\frac{A_{n-i}^{n-i}A_{n-j}^{n-j}}{A_n^nA_{n-i-j}^{n-i-j}}$ã€‚

â€‹	æœ€ç»ˆç­”æ¡ˆä¸ºæ‰€æœ‰åŒºåŸŸçš„è´¡çŒ®å’Œï¼Œå³$\sum S-pS=\sum len_i\times len_j-\sum\frac{A_{n-i}^{n-i}A_{n-j}^{n-j}}{A_n^nA_{n-i-j}^{n-i-j}}\times len_ilen_j$ã€‚

```c++
#include <bits/stdc++.h>
using namespace std;
#define fir first
#define sec second
#define pb push_back
const int mod = 998244353;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){...}
const int N = 2e5+10;
int fac[N], inv[N], ifac[N];
inline void init(int n){
    fac[0] = ifac[0] = inv[1] = 1;
    for(int i=1; i<=n; i++) fac[i] = mul(fac[i-1], i);
    for(int i=2; i<=n; i++) inv[i] = mul(sub(mod,mod/i),inv[mod%i]);
    for(int i=1; i<=n; i++) ifac[i] = mul(ifac[i-1], inv[i]);
}

const int G = 3;
int wn[N<<4], rev[N<<4];
// mod 998244353,1004535809,469762049
int NTT_init(int pn){...}
void NTT(int a[],int n,int f){...}
int n;
map<int, int> mp;
void cal_cover(int a[],int l[],int r[]){
    mp.clear();
    for(int i=1; i<=n; i++) {
        mp[l[i]]++; mp[r[i]]--;
    }
    int pre = -1, num = 0;
    for(auto &pr: mp){
        if(num != 0){
            int len = (pr.fir-1) - pre + 1;
            a[num] += len;
        }
        num += pr.sec;
        pre = pr.fir;
    }
}
int a[N<<4], b[N<<4], c[N<<4], d[N<<4];
int l[N], r[N], s[N], t[N];
int main(){
    scanf("%d",&n);
    for(int i=1; i<=n; i++) scanf("%d%d",l+i,r+i);
    for(int i=1; i<=n; i++) scanf("%d%d",s+i,t+i);
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    cal_cover(a,l,r);
    cal_cover(b,s,t);
    init(n);
    memset(c,0,sizeof(c));
    memset(d,0,sizeof(d));
    int ans = 0;
    int tn = 1; while(tn<n+1) tn<<=1; tn<<=1;
    NTT_init(tn);
    NTT(a,tn,1); NTT(b,tn,1);
    for(int i=0; i<tn; i++) c[i] = mul(a[i],b[i]);
    NTT(a,tn,-1);NTT(b,tn,-1);
    NTT(c,tn,-1);
    for(int i=0; i<tn; i++) ans = add(ans, c[i]);
    for(int i=0; i<=n; i++) {
        a[i] = mul(a[i], fac[n-i]);
        b[i] = mul(b[i], fac[n-i]);
    }
    NTT(a,tn,1); NTT(b,tn,1);
    for(int i=0; i<tn; i++) d[i] = mul(a[i],b[i]);
    NTT(d,tn,-1);
    for(int i=0; i<=n; i++) {
        ans =  sub(ans, mul(mul(ifac[n-i],ifac[n]),d[i]));
    }
    printf("%d\n",ans);
    return 0;
}
```

### æ‹‰æ ¼æœ—æ—¥æ’å€¼

- $n$æ¬¡å¤šé¡¹å¼å¯ä»¥ç”¨$n+1$ä¸ªç‚¹å”¯ä¸€ç¡®å®š
- ä¸€èˆ¬æ–¹æ³•
    - $f_i(x) = (\Pi_{i\neq j}\frac{x-x_j}{x_i-x_j})\times y_i$
    - $g(x)=\sum_{i=0}^n f_i(x)$
- é‡å¿ƒæ‹‰æ ¼æœ—æ—¥
    - æ”¯æŒåŠ¨æ€åŠ ç‚¹ï¼Œæ¯æ¬¡$O(n)$è®¡ç®—$w_i$
    - $l(x)=\Pi_{i=0}^n(x-x_i)$
    - $w_i=\frac{y_i}{\Pi_{i\neq j}(x_i-x_j)}$
    - $g(x)=l(x)\sum _{i=0}^n\frac{w_i}{x-x_i}$

```c++
int x[N], y[N];
int omega[N];
void lagrange_interpolation(){
    for(int i=1; i<=n+1; i++){
        omega[i]=y[i];
        for(int j=1; j<=n+1; j++){
            if(i==j) continue;
            omega[i]=mul(omega[i], rev(sub(x[i],x[j])));
        }
    }
}
int l[N], r[N];
int cal_val(int t){
    l[0]=1; for(int i=1; i<=n+1; i++) l[i]=mul(l[i-1], sub(t,x[i]));
    r[n+2]=1; for(int i=n+1; i>=1; --i) r[i]=mul(r[i+1], sub(t,x[i]));
    int ret=0;
    for(int i=1; i<=n+1; i++) ret=add(ret, mul(omega[i], mul(l[i-1],r[i+1])));
    return ret;
}
```

## ç¦»æ•£æ•°å­¦

### å’Œå¼å…¬å¼

- $\frac{1}{(1-ax)^n}=\sum_{i=0}^{\infty} C_{n+i-1}^{i}a^ix^i$
- $e^x=\sum_{i\ge 0} \frac{x^i}{i!}$
- $\frac{e^x+e^{-x}}{2}=\sum_{i\ge 0} \frac{x^{2i}}{(2i)!}$
- $\frac{e^x-e^{-x}}{2}=\sum_{i\ge 0} \frac{x^{2i+1}}{(2i+1)!}$
- $ln(x)=\sum_{i\ge 1} (-1)^{i+1}\frac{(x-1)^i}{i}$
- $sin(x)=\sum_{i\ge 0} (-1)^i\frac{x^{2i+1}}{(2i+1)!}$
- $cos(x)=\sum_{i\ge 0}(-1)^i\frac{x^{2i}}{(2i)!}$
- $\frac{-a}{1-ax}=[ln(1-ax)]'$
- $(a-x)e^x=\sum_{i\ge 0}\frac{(a-i)x^i}{i!}$

### ç»„åˆè®¡æ•°å…¬å¼

- $C_n^m=C_{n-1}^{m-1}+C_{n-1}^m$
- $C_n^0+C_n^2+C_n^4+...=C_n^1+C_n^3+C_n^5+...=2^{n-1}$
- $1\times C_n^1+2\times C_n^2+3\times C_n^3+...+n\times C_n^n=n\times 2^{n-1}$
- $1^2\times C_n^1+2^2\times C_n^2+3^2\times C_n^3+...+n^2\times C_n^n=n\times (n+1)\times 2^{n-2}$
- $\frac{C_n^1}{1}-\frac{C_n^2}{2}+\frac{C_n^3}{3}-...+(-1)^n\frac{C_n^n}{n}=1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n}$
- $(C_n^0)^2+(C_n^1)^2+...+(C_n^n)^2=C_{2n}^n$
- $\sum_{i=0}^kC_n^iC_m^{k-i}=C_{n+m}^k$
- $\sum_{i=0}^nC_n^iC_{n}^{i-1}=C_{2n}^{n-1}$

### æ–¯ç‰¹æ—æ•°

- ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°
    - $S(n,m)$è¡¨ç¤ºçš„æ˜¯æŠŠ$n$ä¸ª**ä¸åŒ**çš„å°çƒæ”¾åœ¨$m$ä¸ª**ç›¸åŒ**çš„ç›’å­é‡Œæ–¹æ¡ˆæ•°ã€‚
    - é€’æ¨ï¼š$S(n,m)=S(nâˆ’1,mâˆ’1)+mS(nâˆ’1,m)$	
    - å®¹æ–¥ï¼š$S(n,m)=\frac{1}{m!}\sum_{k=0}^{m}(-1)^kC(m,k)(m-k)^n$

### åº·æ‰˜å±•å¼€

- åº·æ‰˜å±•å¼€
    - $X=a_nÂ·(n-1)!+a_{n-1}Â·(n-2)!+...+a_1Â·0!$ï¼Œå…¶ä¸­$a_i$è¡¨ç¤ºåœ¨$i$ä¹‹åæ¯”$p_i$å°çš„æ•°çš„ä¸ªæ•°ã€‚
- é€†åº·æ‰˜å±•å¼€

```c++
ll a[M], b[M];
void ICantor(int n,ll x){
    vector<int> vec;
    for(int i=1; i<=n; i++) vec.pb(a[i]);
    for(int i=1; i<=n; i++){
        int t = x/frac[n-i];
        x %= frac[n-i];
        b[i] = vec[t];
        vec.erase(vec.begin()+t);
    }
}
```



## çº¿æ€§ä»£æ•°

### é«˜æ–¯æ¶ˆå…ƒ

- æ™®é€šæ–¹ç¨‹ï¼Œæµ®ç‚¹æ•°

```c++
const int maxn = 1e2+10;
const double eps = 1e-10;
double a[maxn][maxn], x[maxn];
int equ, var; // equä¸ªæ–¹ç¨‹ï¼Œvarä¸ªå˜å…ƒ
bool free_x[maxn];

inline bool sgn(double x){return  x>eps || x<-eps;}
void init(int n,int m){
    memset(a, 0, sizeof(a));
    memset(x, 0, sizeof(x));
    memset(free_x,true, sizeof(free_x));
    equ = n, var = m;
}
int gauss(){
    int r=1, c=1;
    while(r<=equ && c<=var){
        int m_r = r;
        for(int i=r+1; i<=equ; i++){
            if(fabs(a[i][c])>fabs(a[m_r][c])) m_r = i;
        }
        if(m_r!=r){
            for(int j=c; j<=var+1; j++) swap(a[r][j],a[m_r][j]);
        }
        if(!sgn(a[r][c])){
            a[r][c] = 0;
            ++c;
            continue;
        }
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]){
                double t = a[i][c]/a[r][c];
                for(int j=c; j<=var+1; j++) a[i][j] -= a[r][j]*t;
            }
        }
        ++r; ++c;
    }

    for(int i=r; i<=equ; i++) if(sgn(a[i][var+1])) return -1;
    if(r <= var){
        for(int i=r; i>=1; --i){
            int f_cnt=0, k=-1;
            for(int j=1; j<=var; j++){
                if(sgn(a[i][j]) && free_x[j]){
                    ++f_cnt;
                    k = j;
                }
            }
            if(f_cnt > 1) continue;
            double s = a[i][var];
            for(int j=1; j<=var; j++){
                if(j!=k) s -= a[i][j]*x[j];
            }
            x[k] = s/a[i][k];
            free_x[k] = false;
        }
        return var-r+1;
    }
    for(int i=var; i>=1; --i){
        double s = a[i][var+1];
        for(int j=i+1; j<=var; j++){
            s -= a[i][j]*x[j];
        }
        x[i] = s/a[i][i];
    }
    return 0;
}
```
- 01å¼‚æˆ–ï¼Œbitsetä¼˜åŒ–

```c++
const int maxn = 5e2+10;
int equ, var; // equä¸ªæ–¹ç¨‹ï¼Œvarä¸ªå˜å…ƒ
bitset<maxn> a[maxn];
int x[maxn]; bool free_x[maxn];
void init(int n,int m){
    for(int i=1; i<=m; i++) x[i] = free_x[i] = 0;
    equ = n, var = m;
}
int xor_gauss(){
    int r=1, c=1;
    while(r<=equ && c<=var){
        int m_r = r;
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]>a[m_r][c]) m_r=i;
        }
        if(a[m_r][c] == 0){
            ++c;
            free_x[c] = true;
            continue;
        }
        if(m_r!=r){
            swap(a[r], a[m_r]);
        }
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]){
                a[i] ^= a[r];
            }
        }
        ++r; ++c;
    }

    for(int i=r; i<=equ; i++) if(a[i][var+1]) return -1;
    if(r <= var) return var-r+1;
    for(int i=var; i>=1; --i){
        x[i] = a[i][var+1];
        for(int j=i+1; j<=var; j++){
            x[i] ^= (a[i][j]&&x[j]);
        }
    }
    return 0;
}
```

### HessenbergçŸ©é˜µ

- HessenbergçŸ©é˜µæ˜¯å¦‚ä¸‹å½¢å¼çš„çŸ©é˜µï¼š

$$
\left[\begin{matrix}
x_1 & 0 & 0 & 0 &\cdots & 0 & 0 & a_1 \\
y_1 & x_2 & 0 & 0 &\cdots & 0 & 0 & a_2 \\
0 & y_2 & x_3 & 0 &\cdots & 0 & 0 & a_3 \\
0 & 0 & y_3 & x_4 &\cdots & 0 & 0 & a_4 \\
\vdots & \vdots & \vdots & \vdots & \ddots &\vdots & \vdots &\vdots \\
0 & 0 & 0 & 0 &\cdots &x_{n-2} &0 & a_{n-2}\\
0 & 0 & 0 & 0 &\cdots &y_{n-2} &x_{n-1} & a_{n-1}\\
0 & 0 & 0 & 0 &\cdots &0 & y_{n-1} & x_{n}
\end{matrix}\right]
$$

- è®¾$A^{H}$ä¸ºçŸ©é˜µ$A$ç»è¿‡å˜æ¢å¾—åˆ°çš„$Hessenberg$çŸ©é˜µï¼Œæœ‰$(AE)= (A^{H}E)$ã€‚
- $A^{H}$è®¡ç®—è¡Œåˆ—å¼å¤æ‚åº¦ä¸º$O(N^2)$ï¼Œå¯ä»¥ç”¨è¿™ä¸€æ€§è´¨$O(N^3)$è®¡ç®—ç‰¹å¾æ–¹ç¨‹

```c++
//é«˜æ–¯æ¶ˆå…ƒï¼Œå¤„ç†å‡ºHessenbergçŸ©é˜µ
void cal_hessenberg(){
    for(int i=1; i<=n; i++){
        if(a[i+1][i]==0){
            int swp = 0;
            for(int j=i+2; j<=n; j++){
                if(a[j][i]){
                    for(int k=i; k<=n; k++) swap(a[i+1][k],a[j][k]);
                    for(int k=1; k<=n; k++) swap(a[k][i+1],a[k][j]);
                    swp=1; break;
                }
            }
            if(!swp) continue;
        }
        for(int j=i+2; j<=n; j++){
            int coef = mul(a[j][i], rev(a[i+1][i]));
            for(int k=i; k<=n; k++) a[j][k]=sub(a[j][k],mul(a[i+1][k],coef));
            for(int k=1; k<=n; k++) a[k][i+1]=add(a[k][i+1], mul(a[k][j],coef));
        }
    }
}
```

```c++
//HessenbergçŸ©é˜µè¡Œåˆ—å¼è®¡ç®—
int calc(int x){
    int ret=1, flp=0;
    for(int i=1; i<=n; i++) for(int j=1; j<=n; j++) b[i][j] = a[i][j];
    for(int i=1; i<=n; i++) b[i][i] = sub(b[i][i],x);
    for(int i=1; i<=n; i++){
        if(b[i][i]==0 && b[i+1][i]==0) return 0;
        if(b[i][i]==0){
            flp ^= 1;
            for(int j=i; j<=n; j++) swap(b[i][j], b[i+1][j]);
        }
        int coef = mul(b[i+1][i], rev(b[i][i]));
        for(int j=i; j<=n; j++) b[i+1][j] = sub(b[i+1][j], mul(b[i][j],coef));
    }
    for(int i=1; i<=n; i++) ret=mul(ret, b[i][i]);
    return flp? sub(mod, ret): ret;
}
```

### çº¿æ€§åŸº

- åŸåºåˆ—é‡Œä»»æ„ä¸€ä¸ªæ•°éƒ½å¯ä»¥ç”±çº¿æ€§åŸºé‡Œé¢çš„ä¸€äº›æ•°å¼‚æˆ–å¾—åˆ°ï¼›
- çº¿æ€§åŸºé‡Œé¢çš„ä»»æ„ä¸€äº›æ•°å¼‚æˆ–èµ·æ¥éƒ½ä¸èƒ½å¾—åˆ°0ï¼›
- çº¿æ€§åŸºé‡Œé¢çš„æ•°çš„ä¸ªæ•°å”¯ä¸€ï¼Œå¹¶ä¸”åœ¨ä¿æŒæ€§è´¨ä¸€çš„å‰æä¸‹ï¼Œæ•°çš„ä¸ªæ•°æ˜¯æœ€å°‘çš„ï¼›

```c++
struct LB{
    const int M = 60;
    ll b[65]; int tot=0, n;
    void clear(){tot=0; memset(b,0,sizeof(b));}
    void ins(ll x){
        for(int i=M; i>=0; --i){
            if((x>>i)&1){
                if(!b[i]) {tot++; b[i]=x; return;}
                x ^= b[i];
            }
        }
    }
    ll get_max(){
        ll ret=0;
        for(int i=M; i>=0; --i) if((ret^b[i]) > ret) ret ^= b[i];
        return ret;
    }

    ll t[65];
    void pre_work(){
        for(int i=0; i<=M; i++){
            t[i] = b[i];
            for(int j=0; j<i; j++){
                if((t[i]>>j)&1) t[i] ^= t[j];
            }
        }
    }
    ll get_kth(int k){
        if(k==1 && tot<n) return 0;
        if(tot<n) k--;
        pre_work();
        ll ret=0;
        for(int i=0; i<=M; i++) {
            if(t[i]) {
                if(k&1) ret ^= t[i];
                k>>=1;
            }
        }
        return ret;
    }
};
```

### çŸ©é˜µåŠ é€Ÿé€’æ¨

- ä»¥Fibonacciä¸ºä¾‹

````c++
void mul(int f[2],int a[2][2],int mod){
    int c[2];
    memset(c, 0, sizeof(c));
    for(int j=0; j<2; j++){
        for(int k=0; k<2; k++){
            c[j] = add(c[j], mul(f[k],a[k][j],mod),mod);
        }
    }
    memcpy(f, c, sizeof(c));
}
void mulself(int a[2][2],int mod){
    int c[2][2];
    memset(c, 0, sizeof(c));
    for(int i=0; i<2; i++){
        for(int j=0; j<2; j++){
            for(int k=0; k<2; k++){
                c[i][j] = add(c[i][j],mul(a[i][k],a[k][j],mod),mod);
            }
        }
    }
    memcpy(a, c, sizeof(c));
}
void solve(int f[2], int a[2][2], int n, int mod){
    for(; n; n>>=1){
        if(n&1) mul(f, a,mod);
        mulself(a,mod);
    }
}
````

### ç›¸å…³è®¡ç®—

- éšæœº$n$ä¸ª$n$ç»´01å‘é‡ï¼Œè¯¢é—®è¿™$n$ä¸ªå‘é‡çº¿æ€§æ— å…³çš„æ¦‚ç‡
- è§£æ³•
    - ç”±äº$n$ä¸ªå‘é‡çº¿æ€§æ— å…³ï¼Œåˆ™è¿™$n$ä¸ªå‘é‡å¼ æˆçš„ç©ºé—´ç§©ä¸º$n$
    - è€ƒè™‘å°†æ¯æ¬¡éšæœºçš„å‘é‡åŠ å…¥ä¹‹å‰å‘é‡çš„ç©ºé—´ï¼Œåˆ™æœ€å$n$ä¸ªå‘é‡ç§©ä¸º$n$å½“ä¸”ä»…å½“æ¯æ¬¡åŠ å…¥çš„å‘é‡éƒ½ä¸å±äºä¹‹å‰çš„ç©ºé—´ã€‚
    - æ¦‚ç‡ä¸º$f(n)=\Pi _{i=0}^{n-1}\frac{2^n-2^i}{2^n}=\frac{\Pi_{i=0}^{n-1}(2^n-2^i)}{2^{n^2}}=\frac{2f(n-1)+(2^n-1)}{2^{2n-1}}$

## æ¦‚ç‡è®º

- äºŒé¡¹å¼åæ¼”ï¼š$f(n)=\sum_{i=0}^nC_n^ig(i) \Leftrightarrow g(n)=\sum_{i=0}^n(-1)^{n-i}C_n^if(i)$

- $min-max$ å®¹æ–¥ï¼š$max(S)=\sum _{T\subseteq S}(-1)^{|T|-1}min(T)$
    - ç¤¼ç‰©ç®±

é¢˜æ„ï¼š

â€‹	ä¸€ä¸ªç¤¼ç‰©ç®±ç§æœ‰$n$ç§ä¸åŒçš„ç¤¼ç‰©ï¼Œç¬¬$i$ç§ç¤¼ç‰©æœ‰$a_i$ä»¶ã€‚

â€‹	æ¯æ¬¡éšæœºæŠ½å–ä¸€ä»¶ç¤¼ç‰©ï¼Œä¸æ”¾å›ã€‚

â€‹	é—®æœŸæœ›æŠ½å–å¤šå°‘æ¬¡å¯ä»¥æ”¶é›†åˆ°æ¯ä¸€ç§ç¤¼ç‰©ã€‚

â€‹	$1\le n\le 290, 1\le a_i\le 2000, \sum a_i\le 2000$

æ€è·¯

â€‹		ä»¤$X_i$è¡¨ç¤ºæœé›†åˆ°ç¬¬$i$ç§ç¤¼ç‰©æ—¶æœé›†åˆ°çš„ç¤¼ç‰©æ•°é‡ï¼Œè®¾$S=\{X_1,X_2,...,X_n\}$ã€‚

â€‹	é‚£ä¹ˆæ‰€æ±‚å³ä¸ºï¼š$Y=max(S)$ã€‚

â€‹	ç”±$min-max$å®¹æ–¥ï¼Œæœ‰ï¼š$Y=max(S)=\sum_{T\subseteq S}(-1)^{|T|-1}min(T)$ã€‚

â€‹	è€ƒè™‘å¦‚ä½•è®¡ç®—$min(T)$ï¼š

â€‹		è®¾$\sum_{X_i\in T}a_i=a,\sum a_i =b$ï¼Œ

â€‹		é—®é¢˜è½¬åŒ–ä¸ºï¼šä¸€ä¸ªç›’å­é‡Œæœ‰$a$ç™½çƒã€$b-a$é»‘çƒï¼Œæ¯æ¬¡æ‹¿å‡ºä¸€ä¸ªçƒï¼Œé—®ç¬¬ä¸€æ¬¡æ‹¿åˆ°ç™½çƒæ—¶ï¼Œå·²ç»æ‹¿å‡ºçƒçš„ä¸ªæ•°æœŸæœ›ã€‚

â€‹		é‚£ä¹ˆæœ‰ï¼š$min(T)=\sum_{i=0}^{b-a}\frac{C_{b-a}^i}{C_b^i}\times \frac{a}{b-i}\times (1+i)$ã€‚

â€‹	$min(T)$æœ€å¤šæœ‰2000ç§æƒ…å†µï¼Œæš´åŠ›è®¡ç®—å³å¯ã€‚

```c++
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int N = 25;
const int M = 2e3+10;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){...}
int fac[M], ifac[M];
inline int C(int n,int m){
    return mul(fac[n], mul(ifac[m],ifac[n-m]));
}
inline int inv(int x){
    return qpow(x, mod-2);
}
void init(){
    fac[0] = 1;
    for(int i=1; i<M; i++) fac[i] = mul(fac[i-1], i);
    ifac[M-1] = qpow(fac[M-1], mod-2);
    for(int i=M-2; i>=0; --i) ifac[i] = mul(ifac[i+1], i+1);
}
int a[N], f[M], b=0;
int cal(int a){
    if(f[a] != -1) return f[a];
    int ret = 0;
    for(int i=0; i<=b-a; i++){
        int cnt = mul(mul(mul(C(b-a,i), inv(C(b,i))), mul(a, inv(b-i))), i+1);
        ret = add(ret, cnt);
    }
    return f[a] = ret;
}
int main(){
    init();
    int n; cin>>n;
    for(int i=0; i<n; i++) scanf("%d",a+i), b += a[i];
    int D = (1<<n), ans = 0;
    memset(f, -1, sizeof(f));
    for(int i=1; i<D; i++){
        int cnt=0, sum = 0;
        for(int j=0; j<n; j++){
            if((i>>j) & 1) cnt++, sum += a[j];
        }
        if(cnt & 1) ans = add(ans, cal(sum));
        else ans = sub(ans, cal(sum));
    }
    cout<<ans<<endl;
    return 0;
}
```

## å…¶ä»–

- O(1)å¿«é€Ÿä¹˜æ³•

```c++
ll qmul(ll a,ll b, ll mod){
    return (a*b - (ll)((long double)a/mod*b)*mod+mod)%mod; 
}
```

- BM

```c++
// BM æ¨¡ç‰ˆ
namespace linear_seq {
    #define rep(i,a,n) for (int i=a;i<n;i++)
    #define SZ(x) ((int)(x).size())
    typedef vector<int> VI;
    const int N=10010;
    ll res[N],base[N],_c[N],_md[N];
    VI Md;
    ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
    void mul(ll *a,ll *b,int k) {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (int i=k+k-1;i>=k;i--) if (_c[i])
                rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    int solve(ll n,VI a,VI b) { // a ç³»æ•° b åˆå€¼ b[n+1]=a[0]*b[n]+...
        ll ans=0,pnt=0;
        int k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (int p=pnt;p>=0;p--) {
            mul(res,res,k);
            if ((n>>p)&1) {
                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s) {
        VI C(1,1),B(1,1);
        int L=0,m=1,b=1;
        rep(n,0,SZ(s)) {
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if (d==0) ++m;
            else if (2*L<=n) {
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            } else {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a,ll n) {
        VI c = BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};
```

