# 1-数学

----

## 素数检验

-  int 范围内：2, 7, 61
- long long 范围：2, 325, 9375, 28178, 450775, 9780504, 1795265022
- 3E15：2, 2570940, 880937, 610386380, 4130785767
- 4E13：2, 2570940, 211991001, 3749873356

````c++
//已检验int范围没有问题

bool checkQ(ll a, ll n) {
    if (n==2 || a>=n) return 1;
    if (n==1 || !(n&1)) return 0;
    ll d = n-1;
    while ( !(d&1)) d>>=1;
    ll t = pow_mod(a,d,n);
    while (d != n-1 && t != 1 && t != n-1) {
        t = t*t%n;
        d<<=1;
    }
    return t == n-1 || d&1;
}

bool primeQ(ll n) {
    static vector<ll> t = {2, 7, 61};
    if (n <= 1) return false;
    for (auto k: t) if (!checkQ(k, n)) return false;
    return true;
}
````



## NTT & FFT & FWT

### NTT

```c++
const int mod = 998244353;
const int G = 3;

int wn[N<<2], rev[N<<2];
int NTT_init(int pn){
    int step=0, n = 1;
    for(; n<pn; n<<=1) ++step;
    for(int i=1; i<=n; i++){
        rev[i] = (rev[i>>1]>>1)|((i&1)<<(step-1));
    }
    int g = qpow(G, (mod-1)/n);
    wn[0] = 1;
    for(int i=1; i<=n; i++){
        wn[i] = mul(wn[i-1], g);
    }
    return n;
}
void NTT(int a[], int n,int f){
    for(int i=0; i<=n; i++){
        if(i<rev[i]) swap(a[i], a[rev[i]]);
    }
    for(int k=1; k<n; k<<=1){
        for(int i=0; i<n; i+=(k<<1)){
            int t=n/(k<<1);
            for(int j=0; j<k; j++){
                int w = (f==1)? wn[t*j]:  wn[n-t*j];
                int x = a[i+j];
                int y = mul(a[i+j+k], w);
                a[i+j] = add(x, y);
                a[i+j+k] = sub(x, y);
            }
        }
    }
    if(f == -1){
        int ninv = qpow(n, mod-2);
        for(int i=0; i<=n; i++){
            a[i] = mul(a[i], ninv);
        }
    }
}
```

### FFT

```c++

const double PI = acos(-1);
struct C{
    double r, i;
    C(double r = 0, double i = 0): r(r), i(i){}
};
C operator + (const C&a, const C&b){
    return C(a.r+b.r, a.i+b.i);
}
C operator - (const C&a, const C&b){
    return C(a.r-b.r, a.i-b.i);
}
C operator * (const C&a, const C&b){
    return C(a.r*b.r-a.i*b.i, a.r*b.i + a.i*b.r);
}
void FFT(C x[], int n, int p) {
    for (int i = 0, t = 0; i < n; ++i) {
        if (i > t) swap(x[i], x[t]);
        for (int j = n >> 1; (t ^= j) < j; j >>= 1);
    }
    for (int h = 2; h <= n; h <<= 1) {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i < n; i += h) {
            C w(1, 0), u;
            for (int j = i, k = h >> 1; j < i + k; ++j) {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1){
        for(int i = 0; i<=n; i++) x[i].r /= n;
    }
}

void conv(C a[], C b[], int n) {
    FFT(a, n, 1);
    FFT(b, n, 1);
    for(int i = 0; i<=n; i++){
        a[i] = a[i] * b[i];
    }
    FFT(a, n, -1);
}
```

### FWT

## 线性基

- 原序列里任意一个数都可以由线性基里面的一些数异或得到；
- 线性基里面的任意一些数异或起来都不能得到0；
- 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的；

```c++
const int M = 60;
ll d[M+10]; int tot=0;
void add(ll x){
    for(int i=M; i>=0; --i){
        if(x & (1LL<<i)){
            if(d[i]) x^=d[i];
            else {
                d[i] =  x;
                tot++;
                break;
            }
        }
    }
}
ll get_max(){
    ll ret = 0;
    for(int i=M; i>=0; --i){
        if((ret^d[i]) > ret) ret ^= d[i];
    }
    return ret;
}
ll get_min(){
    for(int i = 0; i<=M; i++){
        if(d[i]) return d[i];
    }
    return 0;
}
ll get_kth(int n,ll k){
    if(k==1 && tot<n) return 0;
    if(tot<n) k--;

    ll td[M+10];
    for(int i=0; i<=M; i++) td[i] = d[i];
    for(int i=1; i<=M; i++){
        for(int j=0; j<i; j++){
            if(d[i] & (1ll<<j)) d[i]^=d[j];
        }
    }
  
    ll ret=0;
    for(int i=0; i<=60; i++){
        if(d[i]){
            if(k&1) ret^=d[i];
            k/=2;
        }
    }
    return ret;
}
```

