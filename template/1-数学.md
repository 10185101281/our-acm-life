# 数学

## 数论

### 素数

- 素数检验
    - int 范围内：2, 7, 61
    - long long 范围：2, 325, 9375, 28178, 450775, 9780504, 1795265022
    - 3E15：2, 2570940, 880937, 610386380, 4130785767
    - 4E13：2, 2570940, 211991001, 3749873356

```c++
//已检验int, long long范围没有问题
bool checkQ(ll a,ll n){
    if(a>=n) return true;
    ll d = n-1;
    while(!(d&1)) d>>=1;
    ll t = pow_mod(a, d, n);
    while(d!=n-1 && t!=1 && t!=n-1){
        t = mul(t, t, n);
        d <<= 1;
    }
    return t==n-1 || d&1;
}
bool primeQ(ll n){
    if(n==2) return true;
    if(n==1 || !(n&1)) return false;
    static vector<ll> t = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    if(n <= 1) return false;
    for(auto k: t) if(!checkQ(k, n)) return false;
    return true;
}
```

- 质因数分解

```c++
//F0RE1GNERS
//分解后的数存入fac中，不保证有序，从1开始
mt19937 mt(time(0));
ll pollard_rho(ll n,ll c){
    ll x = uniform_int_distribution<ll>(1, n-1)(mt), y = x;
    auto f = [&](ll v){ll t = mul(v, v, n) + c; return t < n? t: t-n;};
    while(true){
        x = f(x); y = f(f(y));
        if(x == y) return n;
        ll d = gcd(abs(x-y), n);
        if(d != 1) return d;
    }
}
ll fac[100], fcnt;
void get_fac(ll n, ll cc = 19260817) {
    if (n==4) {fac[++fcnt] = 2; fac[++fcnt] = 2; return;}
    if (primeQ(n)) {fac[++fcnt] = n; return;}
    ll p = n;
    while (p==n) p = pollard_rho(n, --cc);
    get_fac(p);
    get_fac(n / p);
}
void go_fac(ll n){ fcnt = 0; if(n>1) get_fac(n);}
```

```c++
//DCC
//速度可能较快
ll brent(ll n, int steps, int add) {
    if (n % 2 == 0) return 2;
    ll x = 2, y = 2, d = 1;
    while (true) {
        ll tmpx = x, tmpy = y;
        for (int i = 1; i <= steps; i++) {
            x = times(x, x, n) + add;
            if (x >= n) x -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            d = times(d, mns(x, y), n);
        }
        d = gcd(n, d);
        if (d == 1) continue;
        if (d != n) return d;
        x = tmpx, y = tmpy;
        for (int i = 1; i <= steps; i++) {
            x = times(x, x, n) + add;
            if (x >= n) x -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            d = gcd(n, mns(x, y));
            if (d != 1) return d % n;
        }
        return 0;
    }
}
ll fac[100], fcnt;
void work(ll n) {
    if (prime(n)) {
        fac[fcnt++]=n;
        return;
    }
    ll tmp = 0;
    int steps = pow(n, 0.1), add = 1;
    while (tmp == 0) tmp = brent(n, steps, add++);
    work(tmp); work(n / tmp);
}

void go_fac(ll n) {
    fcnt=0;
    work(n);
}
```

### LCM

- n数中最小LCM
    - 暴力枚举约数i，然后暴力枚举i的所有倍数，每次贪心取两个最小的倍数。

```c++
int main(){
    cin>>n;
    int t;
    ans = 0x3f3f3f3f3f3f3f3f;
    for(int i = 1; i<=n; i++){
        scanf("%d",&t);
        if(has[t] && t < ans){
            ans = t;
            x = pos[t];
            y = i;
        }
        has[t] = 1; pos[t] = i;
    }
    for(int i = 1; i<=maxn; i++){
        int pre = 0;
        for(int j = i; j<=maxn; j+=i){
            if(has[j] == 0) continue;
            if(pre == 0){
                pre = j;
            } else {
                ll tmp = (ll)pre/gcd(pre,j)*j;
                if(tmp < ans){
                    x = pos[pre];
                    y = pos[j];
                    ans = tmp;
                }
                break;
            }
        }
    }
    if(x > y)  swap(x,y);
    cout<<x<<' '<<y;
}
```

- n数中最大LCM
    - 暴力枚举约数g，然后从大到小枚举它的倍数。对于倍数x，与最大的和它“除g以外部分互质”的数，做LCM更新答案。
    - 用维护栈技巧优化；“莫比乌斯+容斥”更新和查询 “对于x，‘除g以外部分互质’的数的个数”。

````c++
const int maxn = 1e5;
int stk[maxn+10], tp = 0;
vector<int> d[maxn+10];
int miu[maxn+10], v[maxn+10];
int cnt[maxn+10];
int has[maxn+10];
void add(int x,int y){
    for(auto &t: d[x]){
        cnt[t] += y;
    }
}
int ask(int x){
    int ret = 0;
    for(auto &t: d[x]){
        ret += cnt[t]*miu[t];
    }
    return ret;
}
int gcd(int a,int b){
    return b? gcd(b,a%b): a;
}
void init(){
    for(int i = 1; i<=maxn; i++){
        for(int j = 1; j<=maxn/i; j++){
            d[i*j].pb(i);
        }
    }
    for(int i = 1; i<=maxn; i++) miu[i] = 1, v[i] = 0;
    for(int i = 2; i<=maxn; i++){
        if(v[i]) continue;
        miu[i] = -1;
        for(int j = i*2; j<=maxn; j+=i){
            v[j] = 1;
            if((j/i)%i == 0) miu[j] = 0;
            else miu[j] *= -1;
        }
    }
}
int main(){
    init();
    int n; cin>>n;
    ll ans = 0;
    for(int i = 1; i<=n; i++){
        int x; scanf("%d",&x);
        if(has[x]) ans = max(ans, (ll)x);
        has[x] = 1;
    }
    for(int g = 1; g<=maxn; g++){
        for(int x = maxn/g; x>=1; --x){
            if(!has[x*g]) continue;
            int c = ask(x);
            while(c){
                int y = stk[tp--];
                if(gcd(x,y) == 1) c--;
                if(c == 0) ans = max(ans, 1LL*x*y*g);
                add(y,-1);
            }
            add(x,1);
            stk[++tp] = x;
        }
        while(tp) add(stk[tp--],-1);
    }
    cout<<ans<<endl;
}
````

### 数论前缀和

#### 经典推导

- $\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=1]$

​	$\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=1]$

  =$\sum_{i=1}^n\sum_{j=1}^n\sum_{d|i,d|j}\mu(d)$

  =$\sum_{d=1}^n\mu(d)\sum_{d\mid i}\sum_{d\mid j }1$

  =$\sum_{d=1}^n\mu(d)\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor n/d\rfloor}1$

  =$\sum_{d=1}^n\mu(d)\lfloor \frac{n}{d}\rfloor ^2$



- $\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=k]$

​	$\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=k]$

  =$\sum_{i=1}^n\sum_{j=1}^n\sum_{d|\frac{i}{k},d|\frac{j}{k}}\mu(d)$

  =$\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\sum_{dk\mid i}\sum_{dk\mid j }1$

  =$\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\sum_{i=1}^{\lfloor n/dk\rfloor}\sum_{j=1}^{\lfloor n/dk\rfloor}1$

  =$\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\lfloor \frac{n}{dk}\rfloor ^2$



- $\sum_{i=1}^n\sum_{j=1}^ngcd(i,j)$

​	$\sum_{i=1}^n\sum_{j=1}^mgcd(i,j)$

=$\sum_{k=1}^n\sum_{i=1}^n\sum_{j=1}^nk[gcd(i,j)=k]$

=$\sum_{k=1}^nk\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=k]$

=$\sum_{k=1}^nk\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\lfloor \frac{n}{dk}\rfloor ^2$

​	令$T=dk$

=$\sum_{k=1}^n\sum_{d=1}^{\lfloor n/k\rfloor}k\mu(d)\lfloor \frac{n}{dk}\rfloor ^2$

=$\sum_{T=1}^n\sum_{d\mid T} (\frac{T}{d})\mu(d)\lfloor \frac{n}{T}\rfloor ^2$

=$\sum_{T=1}^n \lfloor\frac{n}{T}\rfloor^2 \sum_{d\mid T}(\frac{T}{d})\mu(d)$

=$\sum_{T=1}^n \lfloor\frac{n}{T}\rfloor^2 \varphi(T)$



- $\sum_{i=1}^n\sum_{j=1}^nlcm(i,j)$

​	$\sum_{i=1}^n\sum_{j=1}^nlcm(i,j)$

  =$\sum_{i=1}^n\sum_{j=1}^n\frac{ij}{gcd(i,j)}$

  =$\sum_{k=1}^{n}\sum_{i=1}^n\sum_{j=1}^n\frac{ij}{k[gcd(i,j)=k]}$

  =$\sum_{k=1}^{n}\sum_{i=1}^{\lfloor n/k\rfloor}\sum_{j=1}^{\lfloor n/k\rfloor}\frac{ikjk}{k}{[gcd(i,j)=1]}$

  =$\sum_{k=1}^{n}k\sum_{i=1}^{\lfloor n/k\rfloor}\sum_{j=1}^{\lfloor n/k\rfloor}ij{[gcd(i,j)=1]}$

  =$\sum_{k=1}^{n}k\sum_{i=1}^{\lfloor n/k\rfloor}\sum_{j=1}^{\lfloor n/k\rfloor}ij\sum_{d|i,d|j}\mu(t)$

  =$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)\sum_{i=1}^{\lfloor n/dk\rfloor}\sum_{j=1}^{\lfloor n/dk\rfloor}idjd$

  =$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)d^2\sum_{i=1}^{\lfloor n/dk\rfloor}\sum_{j=1}^{\lfloor n/dk\rfloor}ij$

  =$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)d^2\sum_{i=1}^{\lfloor n/dk\rfloor}i\sum_{j=1}^{\lfloor n/dk\rfloor}j$

​	记$sum(n)=1+2+...+n=\frac{n(n+1)}{2}$

  =$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor n/k\rfloor}\mu(d)d^2sum(\lfloor n/dk\rfloor)^2$



- $\sum_{{a_1}=1}^n\sum_{{a_2}=1}^n...\sum_{{a_x}=1}^n(\Pi_{j=1}^xa_j^k)f(gcd(a_1,a_2,...,a_x))·gcd(a_1,a_2,...,a_x)$
- 其中$f(x)$定义为：如果存在整数$t(t>1)$使得$t^2$是$x$的因子，那么$f(x)=0$，否则$f(x)=1$。

$\sum_{{a_1}=1}^n\sum_{{a_2}=1}^n...\sum_{{a_x}=1}^n(\Pi_{j=1}^xa_j^k)f(gcd(a_1,a_2,...,a_x))·gcd(a_1,a_2,...,a_x)$

 =$\sum_{d=1}^ndf(d)\sum_{{a_1}=1}^n\sum_{{a_2}=1}^n...\sum_{{a_x}=1}^n(\Pi_{j=1}^xa_j^k)[gcd(a_1,a_2,...,a_n)=d]$

 =$\sum_{d=1}^nd^{kx+1}f(d)\sum_{{a_1}=1}^{\lfloor n/d\rfloor}\sum_{{a_2}=1}^{\lfloor n/d\rfloor}...\sum_{{a_x}=1}^{\lfloor n/d\rfloor}(\Pi_{j=1}^xa_j^k)[gcd(a_1,a_2,...,a_n)=1]$

​	根据$\mu *I = d$，有

 =$\sum_{d=1}^nd^{kx+1}f(d)\sum_{{a_1}=1}^{\lfloor n/d\rfloor}\sum_{{a_2}=1}^{\lfloor n/d\rfloor}...\sum_{{a_x}=1}^{\lfloor n/d\rfloor}(\Pi_{j=1}^xa_j^k)\sum_{t\mid a_1,t\mid a_2,...,t\mid a_x}\mu(t)$

 =$\sum_{d=1}^nd(td)^{kx}f(d)\sum_{t=1}^{\lfloor n/d\rfloor}\mu(t)\sum_{{a_1}=1}^{\lfloor n/dt\rfloor}\sum_{{a_2}=1}^{\lfloor n/dt\rfloor}...\sum_{{a_x}=1}^{\lfloor n/dt\rfloor}(\Pi_{j=1}^xa_j^k)$

 =$\sum_{d=1}^nd(td)^{kx}f(d)\sum_{t=1}^{\lfloor n/d\rfloor}\mu(t)\sum_{{a_1}=1}^{\lfloor n/dt\rfloor}a_1^k\sum_{{a_2}=1}^{\lfloor n/dt\rfloor}a_2^k...\sum_{{a_x}=1}^{\lfloor n/dt\rfloor}a_x^k$

 =$\sum_{d=1}^nd(td)^{kx}f(d)\sum_{t=1}^{\lfloor n/d\rfloor}\mu(t)(\sum_{i=1}^{\lfloor n/dt\rfloor}i^k)^x$

​	令$T=dt$

 =$\sum_{d=1}^n\sum_{t=1}^{\lfloor n/d\rfloor}d(td)^{kx}f(d)\mu(t)(\sum_{i=1}^{\lfloor n/dt\rfloor}i^k)^x$

 =$\sum_{T=1}^n\sum_{d|T}d(T)^{kx}f(d)\mu(\frac{T}{d})(\sum_{i=1}^{\lfloor n/T\rfloor}i^k)^x$

 =$\sum_{T=1}^n(T)^{kx}(\sum_{i=1}^{\lfloor n/T\rfloor}i^k)^x\sum_{d|T}df(d)\mu(\frac{T}{d})$

​	注意到$f(x)=|\mu(x)|$，由于$\mu(x)=0,1,-1$，所以亦可以写作$f(x)=\mu(x)^2$（方便计算）。

 =$\sum_{T=1}^n(T)^{kx}(\sum_{i=1}^{\lfloor n/T\rfloor}i^k)^x\sum_{d|T}d\mu(d)^2\mu(\frac{T}{d})$  

​	令$g(T)=\sum_{d|T}d\mu(d)^2\mu(\frac{T}{d}),s(T)=\sum_{i=1}^{T}i^k$

 =$\sum_{T=1}^ns(\lfloor n/T\rfloor)^x(T)^{kx}g(T)$  

​	预处理$s(T),g(T)$并预处理$(T)^{kx}g(T)$的前缀和，那么对于每个n就可以用数论分块$O(\sqrt n)$的回答。

## 高数

### 卷积

- FFT

```c++
const double PI = acos(-1);
struct C{
    double r, i;
    C(double r = 0, double i = 0): r(r), i(i){}
};
C operator + (const C&a, const C&b){
    return C(a.r+b.r, a.i+b.i);
}
C operator - (const C&a, const C&b){
    return C(a.r-b.r, a.i-b.i);
}
C operator * (const C&a, const C&b){
    return C(a.r*b.r-a.i*b.i, a.r*b.i + a.i*b.r);
}
void FFT(C x[], int n, int p) {
    for (int i = 0, t = 0; i < n; ++i) {
        if (i > t) swap(x[i], x[t]);
        for (int j = n >> 1; (t ^= j) < j; j >>= 1);
    }
    for (int h = 2; h <= n; h <<= 1) {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i < n; i += h) {
            C w(1, 0), u;
            for (int j = i, k = h >> 1; j < i + k; ++j) {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1){
        for(int i = 0; i<=n; i++) x[i].r /= n;
    }
}

void conv(C a[], C b[], int n) {
    FFT(a, n, 1);
    FFT(b, n, 1);
    for(int i = 0; i<=n; i++){
        a[i] = a[i] * b[i];
    }
    FFT(a, n, -1);
}
```

- NTT

```c++
//G为原根
const int N = 2e5+10;
const int G = 3;
int wn[N<<4], rev[N<<4];
int NTT_init(int pn){
    int step=0; int n = 1;
    for(; n<pn; n<<=1) ++step;
    for(int i=1; i<n; i++) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(step-1));
    int g = qpow(G,(mod-1)/n);
    wn[0] = 1;
    for(int i=1; i<=n; i++) wn[i] = mul(wn[i-1], g);
    return n;
}
void NTT(int a[],int n,int f){
    for(int i=0; i<n; i++){
        if(i<rev[i]) swap(a[i], a[rev[i]]);
    }
    for(int k=1; k<n; k<<=1){
        for(int i=0; i<n; i+=(k<<1)){
            int t = n/(k<<1);
            for(int j=0; j<k; j++){
                int w = (f==1)? wn[t*j]: wn[n-t*j];
                int x = a[i+j];
                int y = mul(a[i+j+k], w);
                a[i+j] = add(x, y);
                a[i+j+k] = sub(x, y);
            }
        }
    }
    if(f == -1){
        int ninv = qpow(n, mod-2);
        for(int i=0; i<n; i++) a[i] = mul(a[i], ninv);
    }
}
```

- 分治NTT
    - 例题：给定序列$g_{1...n-1}$，求序列$f_{0...n-1}$。其中$f_i=\sum_{j=1}^if_{i-j}g_j,f_0=1$。

```c++
#include <bits/stdc++.h>
using namespace std;

const int mod = 998244353;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b & 1) ret=mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}

const int N = 2e5+10;
const int G = 3;
int wn[N<<4], rev[N<<4];
// mod 998244353,1004535809,469762049
int NTT_init(int pn){
    int step=0; int n = 1;
    for(; n<pn; n<<=1) ++step;
    for(int i=1; i<n; i++) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(step-1));
    int g = qpow(G,(mod-1)/n);
    wn[0] = 1;
    for(int i=1; i<=n; i++) wn[i] = mul(wn[i-1], g);
    return n;
}
void NTT(int a[],int n,int f){
    for(int i=0; i<n; i++){
        if(i<rev[i]) swap(a[i], a[rev[i]]);
    }
    for(int k=1; k<n; k<<=1){
        for(int i=0; i<n; i+=(k<<1)){
            int t = n/(k<<1);
            for(int j=0; j<k; j++){
                int w = (f==1)? wn[t*j]: wn[n-t*j];
                int x = a[i+j];
                int y = mul(a[i+j+k], w);
                a[i+j] = add(x, y);
                a[i+j+k] = sub(x, y);
            }
        }
    }
    if(f == -1){
        int ninv = qpow(n, mod-2);
        for(int i=0; i<n; i++) a[i] = mul(a[i], ninv);
    }
}
int f[N], g[N];
int a[N<<4], b[N<<4];
int n;
void solve(int l,int r,int len){
    if(l >= n) return ;
    if(len == 1) return ;
    int tlen = len>>1;
    int mid = (l+r)>>1;
    solve(l,mid,tlen);
    NTT_init(len);
    for(int i=0; i<len; i++) a[i] = b[i] = 0;
    for(int i=0; i<tlen; i++) a[i] = f[i+l];
    for(int i=0; i<len; i++) b[i] = g[i];
    NTT(a,len,1); NTT(b,len,1);
    for(int i=0; i<len; i++) a[i] = mul(a[i],b[i]);
    NTT(a,len,-1);
    for(int i=tlen; i<len; i++) f[i+l] = add(f[i+l], a[i]);
    solve(mid,r,tlen);
}
int main(){
    cin>>n;
    int tn = 1; while(tn<n) tn<<=1;
    for(int i=0; i<tn; i++) g[i] = 0;
    for(int i=1; i<n; i++) scanf("%d",g+i);
    for(int i=0; i<tn; i++) f[i] = 0; f[0] = 1;
    solve(0, tn, tn);
    for(int i=0; i<n; i++) printf("%d%c",f[i]," \n"[i==n]);
    return 0;
}
```

### 拉格朗日插值

- $n$次多项式可以用$n+1$个点唯一确定
- 一般方法
    - $f_i(x) = (\Pi_{i\neq j}\frac{x-x_j}{x_i-x_j})\times y_i$
    - $g(x)=\sum_{i=0}^n f_i(x)$
- 重心拉格朗日
    - 支持动态加点，每次$O(n)$计算$w_i$
    - $l(x)=\Pi_{i=0}^n(x-x_i)$
    - $w_i=\frac{y_i}{\Pi_{i\neq j}(x_i-x_j)}$
    - $g(x)=l(x)\sum _{i=0}^n\frac{w_i}{x-x_i}$

```c++
int x[N], y[N];
int omega[N];
void lagrange_interpolation(){
    for(int i=1; i<=n+1; i++){
        omega[i]=y[i];
        for(int j=1; j<=n+1; j++){
            if(i==j) continue;
            omega[i]=mul(omega[i], rev(sub(x[i],x[j])));
        }
    }
}
int l[N], r[N];
int cal_val(int t){
    l[0]=1; for(int i=1; i<=n+1; i++) l[i]=mul(l[i-1], sub(t,x[i]));
    r[n+2]=1; for(int i=n+1; i>=1; --i) r[i]=mul(r[i+1], sub(t,x[i]));
    int ret=0;
    for(int i=1; i<=n+1; i++) ret=add(ret, mul(omega[i], mul(l[i-1],r[i+1])));
    return ret;
}
```

## 离散数学

### 和式公式

- $\frac{1}{(1-ax)^n}=\sum_{i=0}^{\infty} C_{n+i-1}^{i}a^ix^i$
- $e^x=\sum_{i\ge 0} \frac{x^i}{i!}$
- $\frac{e^x+e^{-x}}{2}=\sum_{i\ge 0} \frac{x^{2i}}{(2i)!}$
- $\frac{e^x-e^{-x}}{2}=\sum_{i\ge 0} \frac{x^{2i+1}}{(2i+1)!}$
- $ln(x)=\sum_{i\ge 1} (-1)^{i+1}\frac{(x-1)^i}{i}$
- $sin(x)=\sum_{i\ge 0} (-1)^i\frac{x^{2i+1}}{(2i+1)!}$
- $cos(x)=\sum_{i\ge 0}(-1)^i\frac{x^{2i}}{(2i)!}$
- $\frac{-a}{1-ax}=[ln(1-ax)]'$
- $(a-x)e^x=\sum_{i\ge 0}\frac{(a-i)x^i}{i!}$

### 组合计数公式

- $C_n^m=C_{n-1}^{m-1}+C_{n-1}^m$
- $C_n^0+C_n^2+C_n^4+...=C_n^1+C_n^3+C_n^5+...=2^{n-1}$
- $1\times C_n^1+2\times C_n^2+3\times C_n^3+...+n\times C_n^n=n\times 2^{n-1}$
- $1^2\times C_n^1+2^2\times C_n^2+3^2\times C_n^3+...+n^2\times C_n^n=n\times (n+1)\times 2^{n-2}$
- $\frac{C_n^1}{1}-\frac{C_n^2}{2}+\frac{C_n^3}{3}-...+(-1)^n\frac{C_n^n}{n}=1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n}$
- $(C_n^0)^2+(C_n^1)^2+...+(C_n^n)^2=C_{2n}^n$
- $\sum_{i=0}^kC_n^iC_m^{k-i}=C_{n+m}^k$
- $\sum_{i=0}^nC_n^iC_{n}^{i-1}=C_{2n}^{n-1}$

### 斯特林数

- 第二类斯特林数
    - $S(n,m)$表示的是把$n$个**不同**的小球放在$m$个**相同**的盒子里方案数。
    - 递推：$S(n,m)=S(n−1,m−1)+mS(n−1,m)$	
    - 容斥：$S(n,m)=\frac{1}{m!}\sum_{k=0}^{m}(-1)^kC(m,k)(m-k)^n$

### 康托展开

- 康托展开
    - $X=a_n·(n-1)!+a_{n-1}·(n-2)!+...+a_1·0!$，其中$a_i$表示在$i$之后比$p_i$小的数的个数。
- 逆康托展开

```c++
ll a[M], b[M];
void ICantor(int n,ll x){
    vector<int> vec;
    for(int i=1; i<=n; i++) vec.pb(a[i]);
    for(int i=1; i<=n; i++){
        int t = x/frac[n-i];
        x %= frac[n-i];
        b[i] = vec[t];
        vec.erase(vec.begin()+t);
    }
}
```



## 线性代数

### 高斯消元

- 普通方程，浮点数

```c++
const int maxn = 1e2+10;
const double eps = 1e-10;
double a[maxn][maxn], x[maxn];
int equ, var; // equ个方程，var个变元
bool free_x[maxn];

inline bool sgn(double x){return  x>eps || x<-eps;}
void init(int n,int m){
    memset(a, 0, sizeof(a));
    memset(x, 0, sizeof(x));
    memset(free_x,true, sizeof(free_x));
    equ = n, var = m;
}
int gauss(){
    int r=1, c=1;
    while(r<=equ && c<=var){
        int m_r = r;
        for(int i=r+1; i<=equ; i++){
            if(fabs(a[i][c])>fabs(a[m_r][c])) m_r = i;
        }
        if(m_r!=r){
            for(int j=c; j<=var+1; j++) swap(a[r][j],a[m_r][j]);
        }
        if(!sgn(a[r][c])){
            a[r][c] = 0;
            ++c;
            continue;
        }
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]){
                double t = a[i][c]/a[r][c];
                for(int j=c; j<=var+1; j++) a[i][j] -= a[r][j]*t;
            }
        }
        ++r; ++c;
    }

    for(int i=r; i<=equ; i++) if(sgn(a[i][var+1])) return -1;
    if(r <= var){
        for(int i=r; i>=1; --i){
            int f_cnt=0, k=-1;
            for(int j=1; j<=var; j++){
                if(sgn(a[i][j]) && free_x[j]){
                    ++f_cnt;
                    k = j;
                }
            }
            if(f_cnt > 1) continue;
            double s = a[i][var];
            for(int j=1; j<=var; j++){
                if(j!=k) s -= a[i][j]*x[j];
            }
            x[k] = s/a[i][k];
            free_x[k] = false;
        }
        return var-r+1;
    }
    for(int i=var; i>=1; --i){
        double s = a[i][var+1];
        for(int j=i+1; j<=var; j++){
            s -= a[i][j]*x[j];
        }
        x[i] = s/a[i][i];
    }
    return 0;
}
```
- 01异或，bitset优化

```c++
const int maxn = 5e2+10;
int equ, var; // equ个方程，var个变元
bitset<maxn> a[maxn];
int x[maxn]; bool free_x[maxn];
void init(int n,int m){
    for(int i=1; i<=m; i++) x[i] = free_x[i] = 0;
    equ = n, var = m;
}
int xor_gauss(){
    int r=1, c=1;
    while(r<=equ && c<=var){
        int m_r = r;
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]>a[m_r][c]) m_r=i;
        }
        if(a[m_r][c] == 0){
            ++c;
            free_x[c] = true;
            continue;
        }
        if(m_r!=r){
            swap(a[r], a[m_r]);
        }
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]){
                a[i] ^= a[r];
            }
        }
        ++r; ++c;
    }

    for(int i=r; i<=equ; i++) if(a[i][var+1]) return -1;
    if(r <= var) return var-r+1;
    for(int i=var; i>=1; --i){
        x[i] = a[i][var+1];
        for(int j=i+1; j<=var; j++){
            x[i] ^= (a[i][j]&&x[j]);
        }
    }
    return 0;
}
```

### Hessenberg矩阵

- Hessenberg矩阵是如下形式的矩阵：

$$
\left[\begin{matrix}
x_1 & 0 & 0 & 0 &\cdots & 0 & 0 & a_1 \\
y_1 & x_2 & 0 & 0 &\cdots & 0 & 0 & a_2 \\
0 & y_2 & x_3 & 0 &\cdots & 0 & 0 & a_3 \\
0 & 0 & y_3 & x_4 &\cdots & 0 & 0 & a_4 \\
\vdots & \vdots & \vdots & \vdots & \ddots &\vdots & \vdots &\vdots \\
0 & 0 & 0 & 0 &\cdots &x_{n-2} &0 & a_{n-2}\\
0 & 0 & 0 & 0 &\cdots &y_{n-2} &x_{n-1} & a_{n-1}\\
0 & 0 & 0 & 0 &\cdots &0 & y_{n-1} & x_{n}
\end{matrix}\right]
$$

- 设$A^{H}$为矩阵$A$经过变换得到的$Hessenberg$矩阵，有$(AE)= (A^{H}E)$。
- $A^{H}$计算行列式复杂度为$O(N^2)$，可以用这一性质$O(N^3)$计算特征方程

```c++
//高斯消元，处理出Hessenberg矩阵
void cal_hessenberg(){
    for(int i=1; i<=n; i++){
        if(a[i+1][i]==0){
            int swp = 0;
            for(int j=i+2; j<=n; j++){
                if(a[j][i]){
                    for(int k=i; k<=n; k++) swap(a[i+1][k],a[j][k]);
                    for(int k=1; k<=n; k++) swap(a[k][i+1],a[k][j]);
                    swp=1; break;
                }
            }
            if(!swp) continue;
        }
        for(int j=i+2; j<=n; j++){
            int coef = mul(a[j][i], rev(a[i+1][i]));
            for(int k=i; k<=n; k++) a[j][k]=sub(a[j][k],mul(a[i+1][k],coef));
            for(int k=1; k<=n; k++) a[k][i+1]=add(a[k][i+1], mul(a[k][j],coef));
        }
    }
}
```

```c++
//Hessenberg矩阵行列式计算
int calc(int x){
    int ret=1, flp=0;
    for(int i=1; i<=n; i++) for(int j=1; j<=n; j++) b[i][j] = a[i][j];
    for(int i=1; i<=n; i++) b[i][i] = sub(b[i][i],x);
    for(int i=1; i<=n; i++){
        if(b[i][i]==0 && b[i+1][i]==0) return 0;
        if(b[i][i]==0){
            flp ^= 1;
            for(int j=i; j<=n; j++) swap(b[i][j], b[i+1][j]);
        }
        int coef = mul(b[i+1][i], rev(b[i][i]));
        for(int j=i; j<=n; j++) b[i+1][j] = sub(b[i+1][j], mul(b[i][j],coef));
    }
    for(int i=1; i<=n; i++) ret=mul(ret, b[i][i]);
    return flp? sub(mod, ret): ret;
}
```

### 线性基

- 原序列里任意一个数都可以由线性基里面的一些数异或得到；
- 线性基里面的任意一些数异或起来都不能得到0；
- 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的；

```c++
const int M = 60;
ll d[M+10]; int tot=0;
void add(ll x){
    for(int i=M; i>=0; --i){
        if(x & (1LL<<i)){
            if(d[i]) x^=d[i];
            else {
                d[i] =  x;
                tot++;
                break;
            }
        }
    }
}
ll get_max(){
    ll ret = 0;
    for(int i=M; i>=0; --i){
        if((ret^d[i]) > ret) ret ^= d[i];
    }
    return ret;
}
ll get_min(){
    for(int i = 0; i<=M; i++){
        if(d[i]) return d[i];
    }
    return 0;
}
ll get_kth(int n,ll k){
    if(k==1 && tot<n) return 0;
    if(tot<n) k--;

    ll td[M+10];
    for(int i=0; i<=M; i++) td[i] = d[i];
    for(int i=1; i<=M; i++){
        for(int j=0; j<i; j++){
            if(d[i] & (1ll<<j)) d[i]^=d[j];
        }
    }
  
    ll ret=0;
    for(int i=0; i<=60; i++){
        if(d[i]){
            if(k&1) ret^=d[i];
            k/=2;
        }
    }
    return ret;
}
```

 ### 生成树计数

> Matrix-tree Theorem
>
> ​	设图$G=(V,E)$，拉普拉斯矩阵$L$，则$G$的生成树个数等于$detL_0$，其中$L_0=0$是去掉$L$第i列第i行得到的子矩阵（i任意）。
>
> ​	定义G的拉普拉斯矩阵（Laplacian matrix）$L(G)$：
>
> ​	$$L_{ij}=\begin{cases}-m_{ij}(number\ of\ edges)&i\neq j\\deg(v_i)&i=j \end{cases} \ $$
>
> ​	$L(G)=M(G)M^T(G)$，$M(G)$是G的关联矩阵。

```c++
/*
	给一个n点m边的无向图（无自环）。定义生成树的权值为所有边的按位与。求随机选出一个生成树的权值期望。
*/

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define pii pair<int, int>
#define fir first
#define sec second
const int mod = 998244353;
const int N = 1e2+10;
const int M = 1e4+10;
inline int add(int a,int b) {return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b) {return a<b? a-b+mod: a-b;}
inline int mul(int a,int b) {return 1LL*a*b%mod;}
int qpow(int a, int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}

//高斯消元求行列式
int Determinant(const vector<vector<int>>& A) {
    int res = 1;
    int n = A.size(), cnt = 0;
    vector<vector<int>> B(n, vector<int>(n));
    for (int i = 0; i < n; ++i){
        for (int j = 0; j < n; ++j){
            B[i][j] = A[i][j];
        }
    }
    for (int i = 0; i < n; ++i) {
        int pivot = i;
        for (int j = i; j < n; ++j){
            if (abs(B[j][i]) > abs(B[pivot][i]))pivot = j;
        }
        if (i != pivot) {
            swap(B[i], B[pivot]);
            cnt ^= 1;
        }
        if (B[i][i] == 0) return 0;
        int val = qpow(B[i][i], mod - 2);
        for (int j = i + 1; j < n; ++j) {
            int coe = mul(B[j][i], val);
            for (int k = i; k < n; ++k){
                B[j][k] = sub(B[j][k], mul(coe,B[i][k]));
            }
        }
    }
    for (int i = 0; i < n; ++i) res = mul(res, B[i][i]);
    if (cnt) res = sub(mod, res);
    return res;
}

struct E{
    int x, y, z;
}es[M];

int L[N][N]; vector<vector<int>> A;
int main(){
    int T; cin>>T;
    while(T--){
        int n, m; scanf("%d%d",&n,&m);
        for(int i = 1; i<=m; i++) scanf("%d%d%d",&es[i].x,&es[i].y,&es[i].z);
        memset(L, 0, sizeof(L));
        A.clear();
        for(int i = 1; i<=m; i++){
            int x = es[i].x, y = es[i].y;
            L[x][x]++; L[y][y]++;
            L[x][y]--; L[y][x]--;
        }
        int fz = 0, fm = 0;
        for(int i = 1; i<n; i++){
            vector<int> t;
            for(int j = 1; j<n; j++) t.pb(L[i][j]);
            A.pb(t);
        }
        fm = Determinant(A);
        for(int k = 0; k<30; k++){
            memset(L, 0, sizeof(L));
            A.clear();
            for(int i = 1; i<=m; i++){
                if(es[i].z & (1<<k)){
                    int x = es[i].x, y = es[i].y;
                    L[x][x]++; L[y][y]++;
                    L[x][y]--; L[y][x]--;
                }
            }
            for(int i = 1; i<n; i++){
                vector<int> t;
                for(int j = 1; j<n; j++) t.pb(L[i][j]);
                A.pb(t);
            }
            fz = add(fz, mul(1<<k, Determinant(A)));
        }
        printf("%d\n",mul(fz, qpow(fm,mod-2)));
    }
}
```

### 矩阵加速递推

- 以Fibonacci为例

````c++
void mul(int f[2],int a[2][2],int mod){
    int c[2];
    memset(c, 0, sizeof(c));
    for(int j=0; j<2; j++){
        for(int k=0; k<2; k++){
            c[j] = add(c[j], mul(f[k],a[k][j],mod),mod);
        }
    }
    memcpy(f, c, sizeof(c));
}
void mulself(int a[2][2],int mod){
    int c[2][2];
    memset(c, 0, sizeof(c));
    for(int i=0; i<2; i++){
        for(int j=0; j<2; j++){
            for(int k=0; k<2; k++){
                c[i][j] = add(c[i][j],mul(a[i][k],a[k][j],mod),mod);
            }
        }
    }
    memcpy(a, c, sizeof(c));
}
void solve(int f[2], int a[2][2], int n, int mod){
    for(; n; n>>=1){
        if(n&1) mul(f, a,mod);
        mulself(a,mod);
    }
}
````

## 概率论

- 二项式反演：$f(n)=\sum_{i=0}^nC_n^ig(i) \Leftrightarrow g(n)=\sum_{i=0}^n(-1)^{n-i}C_n^if(i)$

- $min-max$ 容斥：$max(S)=\sum _{T\subseteq S}(-1)^{|T|-1}min(T)$

## 其他

- O(1)快速乘法

```c++
ll qmul(ll a,ll b, ll mod){
    return (a*b - (ll)((long double)a/mod*b)*mod+mod)%mod; 
}
```
