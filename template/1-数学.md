# 1-数学

----

## 1.1 素数

### 1.1.1 素数检验

-  int 范围内：2, 7, 61
- long long 范围：2, 325, 9375, 28178, 450775, 9780504, 1795265022
- 3E15：2, 2570940, 880937, 610386380, 4130785767
- 4E13：2, 2570940, 211991001, 3749873356

````c++
//已检验int, long long范围没有问题

bool checkQ(ll a,ll n){
    if(a>=n) return true;
    ll d = n-1;
    while(!(d&1)) d>>=1;
    ll t = pow_mod(a, d, n);
    while(d!=n-1 && t!=1 && t!=n-1){
        t = mul(t, t, n);
        d <<= 1;
    }
    return t==n-1 || d&1;
}
bool primeQ(ll n){
    if(n==2) return true;
    if(n==1 || !(n&1)) return false;
    static vector<ll> t = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    if(n <= 1) return false;
    for(auto k: t) if(!checkQ(k, n)) return false;
    return true;
}
````

### 1.1.2 质因数分解

- 分解后的数存入fac中，不保证有序，从1开始。

```c++
//kblack
mt19937 mt(time(0));
ll pollard_rho(ll n,ll c){
    ll x = uniform_int_distribution<ll>(1, n-1)(mt), y = x;
    auto f = [&](ll v){ll t = mul(v, v, n) + c; return t < n? t: t-n;};
    while(true){
        x = f(x); y = f(f(y));
        if(x == y) return n;
        ll d = gcd(abs(x-y), n);
        if(d != 1) return d;
    }
}
ll fac[100], fcnt;
void get_fac(ll n, ll cc = 19260817) {
    if (n==4) {fac[++fcnt] = 2; fac[++fcnt] = 2; return;}
    if (primeQ(n)) {fac[++fcnt] = n; return;}
    ll p = n;
    while (p==n) p = pollard_rho(n, --cc);
    get_fac(p);
    get_fac(n / p);
}
void go_fac(ll n){ fcnt = 0; if(n>1) get_fac(n);}
```

```c++
//Once
ll brent(ll n, int steps, int add) {
    if (n % 2 == 0) return 2;
    ll x = 2, y = 2, d = 1;
    while (true) {
        ll tmpx = x, tmpy = y;
        for (int i = 1; i <= steps; i++) {
            x = times(x, x, n) + add;
            if (x >= n) x -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            d = times(d, mns(x, y), n);
        }
        d = gcd(n, d);
        if (d == 1) continue;
        if (d != n) return d;
        x = tmpx, y = tmpy;
        for (int i = 1; i <= steps; i++) {
            x = times(x, x, n) + add;
            if (x >= n) x -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            y = times(y, y, n) + add;
            if (y >= n) y -= n;
            d = gcd(n, mns(x, y));
            if (d != 1) return d % n;
        }
        return 0;
    }
}

ll fac[100], fcnt;

void work(ll n) {
    if (prime(n)) {
        fac[fcnt++]=n;
        return;
    }
    ll tmp = 0;
    int steps = pow(n, 0.1), add = 1;
    while (tmp == 0) tmp = brent(n, steps, add++);
    work(tmp); work(n / tmp);
}

void go_fac(ll n) {
    fcnt=0;
    work(n);
}
```

## 1.2 卷积，NTT & FFT & FWT

### 1.2.1 NTT

```c++
const int N = 2e5+10;
const int G = 3;
int wn[N<<4], rev[N<<4];
int NTT_init(int pn){
    int step=0; int n = 1;
    for(; n<pn; n<<=1) ++step;
    for(int i=1; i<n; i++) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(step-1));
    int g = qpow(G,(mod-1)/n);
    wn[0] = 1;
    for(int i=1; i<=n; i++) wn[i] = mul(wn[i-1], g);
    return n;
}
void NTT(int a[],int n,int f){
    for(int i=0; i<n; i++){
        if(i<rev[i]) swap(a[i], a[rev[i]]);
    }
    for(int k=1; k<n; k<<=1){
        for(int i=0; i<n; i+=(k<<1)){
            int t = n/(k<<1);
            for(int j=0; j<k; j++){
                int w = (f==1)? wn[t*j]: wn[n-t*j];
                int x = a[i+j];
                int y = mul(a[i+j+k], w);
                a[i+j] = add(x, y);
                a[i+j+k] = sub(x, y);
            }
        }
    }
    if(f == -1){
        int ninv = qpow(n, mod-2);
        for(int i=0; i<n; i++) a[i] = mul(a[i], ninv);
    }
}
```

- 分治NTT
- ​	给定序列$g_{1...n-1}$，求序列$f_{0...n-1}$。其中$f_i=\sum_{j=1}^if_{i-j}g_j,f_0=1$。

```c++
#include <bits/stdc++.h>
using namespace std;

const int mod = 998244353;
inline int add(int a,int b){return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b){return a<b? a-b+mod: a-b;}
inline int mul(int a,int b){return 1LL*a*b%mod;}
int qpow(int a,int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b & 1) ret=mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}

const int N = 2e5+10;
const int G = 3;
int wn[N<<4], rev[N<<4];
// mod 998244353,1004535809,469762049
int NTT_init(int pn){
    int step=0; int n = 1;
    for(; n<pn; n<<=1) ++step;
    for(int i=1; i<n; i++) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(step-1));
    int g = qpow(G,(mod-1)/n);
    wn[0] = 1;
    for(int i=1; i<=n; i++) wn[i] = mul(wn[i-1], g);
    return n;
}
void NTT(int a[],int n,int f){
    for(int i=0; i<n; i++){
        if(i<rev[i]) swap(a[i], a[rev[i]]);
    }
    for(int k=1; k<n; k<<=1){
        for(int i=0; i<n; i+=(k<<1)){
            int t = n/(k<<1);
            for(int j=0; j<k; j++){
                int w = (f==1)? wn[t*j]: wn[n-t*j];
                int x = a[i+j];
                int y = mul(a[i+j+k], w);
                a[i+j] = add(x, y);
                a[i+j+k] = sub(x, y);
            }
        }
    }
    if(f == -1){
        int ninv = qpow(n, mod-2);
        for(int i=0; i<n; i++) a[i] = mul(a[i], ninv);
    }
}
int f[N], g[N];
int a[N<<4], b[N<<4];
int n;
void solve(int l,int r,int len){
    if(l >= n) return ;
    if(len == 1) return ;
    int tlen = len>>1;
    int mid = (l+r)>>1;
    solve(l,mid,tlen);
    NTT_init(len);
    for(int i=0; i<len; i++) a[i] = b[i] = 0;
    for(int i=0; i<tlen; i++) a[i] = f[i+l];
    for(int i=0; i<len; i++) b[i] = g[i];
    NTT(a,len,1); NTT(b,len,1);
    for(int i=0; i<len; i++) a[i] = mul(a[i],b[i]);
    NTT(a,len,-1);
    for(int i=tlen; i<len; i++) f[i+l] = add(f[i+l], a[i]);
    solve(mid,r,tlen);
}
int main(){
    cin>>n;
    int tn = 1; while(tn<n) tn<<=1;
    for(int i=0; i<tn; i++) g[i] = 0;
    for(int i=1; i<n; i++) scanf("%d",g+i);
    for(int i=0; i<tn; i++) f[i] = 0; f[0] = 1;
    solve(0, tn, tn);
    for(int i=0; i<n; i++) printf("%d%c",f[i]," \n"[i==n]);
    return 0;
}
```

### 1.2.2 FFT

```c++

const double PI = acos(-1);
struct C{
    double r, i;
    C(double r = 0, double i = 0): r(r), i(i){}
};
C operator + (const C&a, const C&b){
    return C(a.r+b.r, a.i+b.i);
}
C operator - (const C&a, const C&b){
    return C(a.r-b.r, a.i-b.i);
}
C operator * (const C&a, const C&b){
    return C(a.r*b.r-a.i*b.i, a.r*b.i + a.i*b.r);
}
void FFT(C x[], int n, int p) {
    for (int i = 0, t = 0; i < n; ++i) {
        if (i > t) swap(x[i], x[t]);
        for (int j = n >> 1; (t ^= j) < j; j >>= 1);
    }
    for (int h = 2; h <= n; h <<= 1) {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i < n; i += h) {
            C w(1, 0), u;
            for (int j = i, k = h >> 1; j < i + k; ++j) {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1){
        for(int i = 0; i<=n; i++) x[i].r /= n;
    }
}

void conv(C a[], C b[], int n) {
    FFT(a, n, 1);
    FFT(b, n, 1);
    for(int i = 0; i<=n; i++){
        a[i] = a[i] * b[i];
    }
    FFT(a, n, -1);
}
```

### 1.2.3 FWT

## 1.3 线性代数

### 1.3.1 高斯消元

- 普通方程
- 浮点数

```c++
const int maxn = 1e2+10;
const double eps = 1e-10;
double a[maxn][maxn], x[maxn];
int equ, var; // equ个方程，var个变元
bool free_x[maxn];

inline bool sgn(double x){return  x>eps || x<-eps;}
void init(int n,int m){
    memset(a, 0, sizeof(a));
    memset(x, 0, sizeof(x));
    memset(free_x,true, sizeof(free_x));
    equ = n, var = m;
}
int gauss(){
    int r=1, c=1;
    while(r<=equ && c<=var){
        int m_r = r;
        for(int i=r+1; i<=equ; i++){
            if(fabs(a[i][c])>fabs(a[m_r][c])) m_r = i;
        }
        if(m_r!=r){
            for(int j=c; j<=var+1; j++) swap(a[r][j],a[m_r][j]);
        }
        if(!sgn(a[r][c])){
            a[r][c] = 0;
            ++c;
            continue;
        }
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]){
                double t = a[i][c]/a[r][c];
                for(int j=c; j<=var+1; j++) a[i][j] -= a[r][j]*t;
            }
        }
        ++r; ++c;
    }

    for(int i=r; i<=equ; i++) if(sgn(a[i][var+1])) return -1;
    if(r <= var){
        for(int i=r; i>=1; --i){
            int f_cnt=0, k=-1;
            for(int j=1; j<=var; j++){
                if(sgn(a[i][j]) && free_x[j]){
                    ++f_cnt;
                    k = j;
                }
            }
            if(f_cnt > 1) continue;
            double s = a[i][var];
            for(int j=1; j<=var; j++){
                if(j!=k) s -= a[i][j]*x[j];
            }
            x[k] = s/a[i][k];
            free_x[k] = false;
        }
        return var-r+1;
    }
    for(int i=var; i>=1; --i){
        double s = a[i][var+1];
        for(int j=i+1; j<=var; j++){
            s -= a[i][j]*x[j];
        }
        x[i] = s/a[i][i];
    }
    return 0;
}
```

- 01异或方程

```c++
const int maxn = 1e2+10;
int a[maxn][maxn], x[maxn];
int equ, var; // equ个方程，var个变元
bool free_x[maxn];
void init(int n,int m){
    memset(a, 0, sizeof(a));
    memset(x, 0, sizeof(x));
    memset(free_x,false, sizeof(free_x));
    equ = n, var = m;
}
int xor_gauss(){
    int r=1, c=1;
    while(r<=equ && c<=var){
        int m_r = r;
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]>a[m_r][c]) m_r=i;
        }
        if(a[m_r][c] == 0){
            ++c;
            free_x[c] = true;
            continue;
        }

        if(m_r!=r){
            for(int j=c; j<=var+1; j++) swap(a[r][j],a[m_r][j]);
        }
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]){
                for(int j=c; j<=var+1; j++){
                    a[i][j] ^= a[r][j];
                }
            }
        }
        ++r; ++c;
    }

    for(int i=r; i<=equ; i++) if(a[i][var+1]) return -1;
    if(r <= var) return var-r+1;
    for(int i=var; i>=1; --i){
        x[i] = a[i][var+1];
        for(int j=i+1; j<=var; j++){
            x[i] ^= (a[i][j]&&x[j]);
        }
    }
    return 0;
}
```

- bitset优化

```c++
const int maxn = 5e2+10;
int equ, var; // equ个方程，var个变元
bitset<maxn> a[maxn];
int x[maxn]; bool free_x[maxn];
void init(int n,int m){
    for(int i=1; i<=m; i++) x[i] = free_x[i] = 0;
    equ = n, var = m;
}
int xor_gauss(){
    int r=1, c=1;
    while(r<=equ && c<=var){
        int m_r = r;
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]>a[m_r][c]) m_r=i;
        }
        if(a[m_r][c] == 0){
            ++c;
            free_x[c] = true;
            continue;
        }
        if(m_r!=r){
            swap(a[r], a[m_r]);
        }
        for(int i=r+1; i<=equ; i++){
            if(a[i][c]){
                a[i] ^= a[r];
            }
        }
        ++r; ++c;
    }

    for(int i=r; i<=equ; i++) if(a[i][var+1]) return -1;
    if(r <= var) return var-r+1;
    for(int i=var; i>=1; --i){
        x[i] = a[i][var+1];
        for(int j=i+1; j<=var; j++){
            x[i] ^= (a[i][j]&&x[j]);
        }
    }
    return 0;
}
```

### 1.3.2 线性基

- 原序列里任意一个数都可以由线性基里面的一些数异或得到；
- 线性基里面的任意一些数异或起来都不能得到0；
- 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的；

```c++
const int M = 60;
ll d[M+10]; int tot=0;
void add(ll x){
    for(int i=M; i>=0; --i){
        if(x & (1LL<<i)){
            if(d[i]) x^=d[i];
            else {
                d[i] =  x;
                tot++;
                break;
            }
        }
    }
}
ll get_max(){
    ll ret = 0;
    for(int i=M; i>=0; --i){
        if((ret^d[i]) > ret) ret ^= d[i];
    }
    return ret;
}
ll get_min(){
    for(int i = 0; i<=M; i++){
        if(d[i]) return d[i];
    }
    return 0;
}
ll get_kth(int n,ll k){
    if(k==1 && tot<n) return 0;
    if(tot<n) k--;

    ll td[M+10];
    for(int i=0; i<=M; i++) td[i] = d[i];
    for(int i=1; i<=M; i++){
        for(int j=0; j<i; j++){
            if(d[i] & (1ll<<j)) d[i]^=d[j];
        }
    }
  
    ll ret=0;
    for(int i=0; i<=60; i++){
        if(d[i]){
            if(k&1) ret^=d[i];
            k/=2;
        }
    }
    return ret;
}
```

## 1.4 组合数学

### 1.4.1 常用和式公式

- $\frac{1}{(1-ax)^n}=\sum_{i=0}^{\infty} C_{n+i-1}^{i}a^ix^i$
- $e^x=\sum_{i\ge 0} \frac{x^i}{i!}$
- $\frac{e^x+e^{-x}}{2}=\sum_{i\ge 0} \frac{x^{2i}}{(2i)!}$
- $\frac{e^x-e^{-x}}{2}=\sum_{i\ge 0} \frac{x^{2i+1}}{(2i+1)!}$
- $ln(x)=\sum_{i\ge 1} (-1)^{i+1}\frac{(x-1)^i}{i}$
- $sin(x)=\sum_{i\ge 0} (-1)^i\frac{x^{2i+1}}{(2i+1)!}$
- $cos(x)=\sum_{i\ge 0}(-1)^i\frac{x^{2i}}{(2i)!}$
- $\frac{-a}{1-ax}=[ln(1-ax)]'$
- $(a-x)e^x=\sum_{i\ge 0}\frac{(a-i)x^i}{i!}$

### 1.4.2 第二类斯特林数

- $S(n,m)$表示的是把$n$个**不同**的小球放在$m$个**相同**的盒子里方案数。
- 递推：$S(n,m)=S(n−1,m−1)+mS(n−1,m)$	
- 容斥：$S(n,m)=\frac{1}{m!}\sum_{k=0}^{m}(-1)^kC(m,k)(m-k)^n$

### 1.4.3 组合计数

- $C_n^m=C_{n-1}^{m-1}+C_{n-1}^m$
- $C_n^0+C_n^2+C_n^4+...=C_n^1+C_n^3+C_n^5+...=2^{n-1}$
- $1\times C_n^1+2\times C_n^2+3\times C_n^3+...+n\times C_n^n=n\times 2^{n-1}$
- $1^2\times C_n^1+2^2\times C_n^2+3^2\times C_n^3+...+n^2\times C_n^n=n\times (n+1)\times 2^{n-2}$
- $\frac{C_n^1}{1}-\frac{C_n^2}{2}+\frac{C_n^3}{3}-...+(-1)^n\frac{C_n^n}{n}=1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n}$
- $(C_n^0)^2+(C_n^1)^2+...+(C_n^n)^2=C_{2n}^n$
- $\sum_{i=0}^kC_n^iC_m^{k-i}=C_{n+m}^k$
- $\sum_{i=0}^nC_n^iC_{n}^{i-1}=C_{2n}^{n-1}$

## 1.5 计数

### 1.5.1 生成树计数

> Matrix-tree Theorem
>
> ​	设图$G=(V,E)$，拉普拉斯矩阵$L$，则$G$的生成树个数等于$detL_0$，其中$L_0=0$是去掉$L$第i列第i行得到的子矩阵（i任意）。
>
> ​	定义G的拉普拉斯矩阵（Laplacian matrix）$L(G)$：
>
> ​	$$L_{ij}=\begin{cases}-m_{ij}(number\ of\ edges)&i\neq j\\deg(v_i)&i=j \end{cases} \ $$
>
> ​	$L(G)=M(G)M^T(G)$，$M(G)$是G的关联矩阵。

```c++
/*
	给一个n点m边的无向图（无自环）。定义生成树的权值为所有边的按位与。求随机选出一个生成树的权值期望。
*/

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define pii pair<int, int>
#define fir first
#define sec second
const int mod = 998244353;
const int N = 1e2+10;
const int M = 1e4+10;
inline int add(int a,int b) {return a+b>=mod? a+b-mod: a+b;}
inline int sub(int a,int b) {return a<b? a-b+mod: a-b;}
inline int mul(int a,int b) {return 1LL*a*b%mod;}
int qpow(int a, int b){
    int ret = 1;
    for(; b; b>>=1){
        if(b & 1) ret = mul(ret, a);
        a = mul(a, a);
    }
    return ret;
}

//高斯消元求行列式
int Determinant(const vector<vector<int>>& A) {
    int res = 1;
    int n = A.size(), cnt = 0;
    vector<vector<int>> B(n, vector<int>(n));
    for (int i = 0; i < n; ++i){
        for (int j = 0; j < n; ++j){
            B[i][j] = A[i][j];
        }
    }
    for (int i = 0; i < n; ++i) {
        int pivot = i;
        for (int j = i; j < n; ++j){
            if (abs(B[j][i]) > abs(B[pivot][i]))pivot = j;
        }
        if (i != pivot) {
            swap(B[i], B[pivot]);
            cnt ^= 1;
        }
        if (B[i][i] == 0) return 0;
        int val = qpow(B[i][i], mod - 2);
        for (int j = i + 1; j < n; ++j) {
            int coe = mul(B[j][i], val);
            for (int k = i; k < n; ++k){
                B[j][k] = sub(B[j][k], mul(coe,B[i][k]));
            }
        }
    }
    for (int i = 0; i < n; ++i) res = mul(res, B[i][i]);
    if (cnt) res = sub(mod, res);
    return res;
}

struct E{
    int x, y, z;
}es[M];

int L[N][N]; vector<vector<int>> A;
int main(){
    int T; cin>>T;
    while(T--){
        int n, m; scanf("%d%d",&n,&m);
        for(int i = 1; i<=m; i++) scanf("%d%d%d",&es[i].x,&es[i].y,&es[i].z);
        memset(L, 0, sizeof(L));
        A.clear();
        for(int i = 1; i<=m; i++){
            int x = es[i].x, y = es[i].y;
            L[x][x]++; L[y][y]++;
            L[x][y]--; L[y][x]--;
        }
        int fz = 0, fm = 0;
        for(int i = 1; i<n; i++){
            vector<int> t;
            for(int j = 1; j<n; j++) t.pb(L[i][j]);
            A.pb(t);
        }
        fm = Determinant(A);
        for(int k = 0; k<30; k++){
            memset(L, 0, sizeof(L));
            A.clear();
            for(int i = 1; i<=m; i++){
                if(es[i].z & (1<<k)){
                    int x = es[i].x, y = es[i].y;
                    L[x][x]++; L[y][y]++;
                    L[x][y]--; L[y][x]--;
                }
            }
            for(int i = 1; i<n; i++){
                vector<int> t;
                for(int j = 1; j<n; j++) t.pb(L[i][j]);
                A.pb(t);
            }
            fz = add(fz, mul(1<<k, Determinant(A)));
        }
        printf("%d\n",mul(fz, qpow(fm,mod-2)));
    }
}
```

## 1.6 LCM

### 1.6.1 n数中最小LCM

- 暴力枚举约数i，然后暴力枚举i的所有倍数，每次贪心取两个最小的倍数。

```c++
int main(){
    cin>>n;
    int t;
    ans = 0x3f3f3f3f3f3f3f3f;
    for(int i = 1; i<=n; i++){
        scanf("%d",&t);
        if(has[t] && t < ans){
            ans = t;
            x = pos[t];
            y = i;
        }
        has[t] = 1; pos[t] = i;
    }
    for(int i = 1; i<=maxn; i++){
        int pre = 0;
        for(int j = i; j<=maxn; j+=i){
            if(has[j] == 0) continue;
            if(pre == 0){
                pre = j;
            } else {
                ll tmp = (ll)pre/gcd(pre,j)*j;
                if(tmp < ans){
                    x = pos[pre];
                    y = pos[j];
                    ans = tmp;
                }
                break;
            }
        }
    }
    if(x > y)  swap(x,y);
    cout<<x<<' '<<y;
}
```

### 1.6.2 n数中最大LCM

- 暴力枚举约数g，然后从大到小枚举它的倍数。对于倍数x，与最大的和它“除g以外部分互质”的数，做LCM更新答案。
- 用维护栈技巧优化；“莫比乌斯+容斥”更新和查询 “对于x，‘除g以外部分互质’的数的个数”。

```c++
const int maxn = 1e5;
int stk[maxn+10], tp = 0;
vector<int> d[maxn+10];
int miu[maxn+10], v[maxn+10];
int cnt[maxn+10];
int has[maxn+10];
void add(int x,int y){
    for(auto &t: d[x]){
        cnt[t] += y;
    }
}
int ask(int x){
    int ret = 0;
    for(auto &t: d[x]){
        ret += cnt[t]*miu[t];
    }
    return ret;
}
int gcd(int a,int b){
    return b? gcd(b,a%b): a;
}
void init(){
    for(int i = 1; i<=maxn; i++){
        for(int j = 1; j<=maxn/i; j++){
            d[i*j].pb(i);
        }
    }
    for(int i = 1; i<=maxn; i++) miu[i] = 1, v[i] = 0;
    for(int i = 2; i<=maxn; i++){
        if(v[i]) continue;
        miu[i] = -1;
        for(int j = i*2; j<=maxn; j+=i){
            v[j] = 1;
            if((j/i)%i == 0) miu[j] = 0;
            else miu[j] *= -1;
        }
    }
}
int main(){
    init();
    int n; cin>>n;
    ll ans = 0;
    for(int i = 1; i<=n; i++){
        int x; scanf("%d",&x);
        if(has[x]) ans = max(ans, (ll)x);
        has[x] = 1;
    }
    for(int g = 1; g<=maxn; g++){
        for(int x = maxn/g; x>=1; --x){
            if(!has[x*g]) continue;
            int c = ask(x);
            while(c){
                int y = stk[tp--];
                if(gcd(x,y) == 1) c--;
                if(c == 0) ans = max(ans, 1LL*x*y*g);
                add(y,-1);
            }
            add(x,1);
            stk[++tp] = x;
        }
        while(tp) add(stk[tp--],-1);
    }
    cout<<ans<<endl;
}
```

## 1.7 矩阵加速递推

- 以Fibonacci为例

```c++
void mul(int f[2],int a[2][2],int mod){
    int c[2];
    memset(c, 0, sizeof(c));
    for(int j=0; j<2; j++){
        for(int k=0; k<2; k++){
            c[j] = add(c[j], mul(f[k],a[k][j],mod),mod);
        }
    }
    memcpy(f, c, sizeof(c));
}
void mulself(int a[2][2],int mod){
    int c[2][2];
    memset(c, 0, sizeof(c));
    for(int i=0; i<2; i++){
        for(int j=0; j<2; j++){
            for(int k=0; k<2; k++){
                c[i][j] = add(c[i][j],mul(a[i][k],a[k][j],mod),mod);
            }
        }
    }
    memcpy(a, c, sizeof(c));
}
void solve(int f[2], int a[2][2], int n, int mod){
    for(; n; n>>=1){
        if(n&1) mul(f, a,mod);
        mulself(a,mod);
    }
}
```

## 1.8 其他

- 二项式反演：$f(n)=\sum_{i=0}^nC_n^ig(i) \Leftrightarrow g(n)=\sum_{i=0}^n(-1)^{n-i}C_n^if(i)$

- $min-max$ 容斥：$max(S)=\sum _{T\subseteq S}(-1)^{|T|-1}min(T)$

- 康托展开：$X=a_n·(n-1)!+a_{n-1}·(n-2)!+...+a_1·0!$，其中$a_i$表示在$i$之后比$p_i$小的数的个数。


````c++
ll a[M], b[M];
void ICantor(int n,ll x){
    vector<int> vec;
    for(int i=1; i<=n; i++) vec.pb(a[i]);
    for(int i=1; i<=n; i++){
        int t = x/frac[n-i];
        x %= frac[n-i];
        b[i] = vec[t];
        vec.erase(vec.begin()+t);
    }
}
````

- O(1)快速乘法

```c++
ll qmul(ll a,ll b, ll mod){
    return (a*b - (ll)((long double)a/mod*b)*mod+mod)%mod; 
}
```

- 二维空间旋转矩阵
    - 逆时针旋转$\theta$

$$
M(\theta)=\left[\begin{matrix}cos\theta & -sin\theta \\ sin\theta & cos\theta\end{matrix}\right] = cos\theta \left[\begin{matrix}1 & 0 \\ 0 &1\end{matrix}\right] +  sin\theta \left[\begin{matrix}0 & -1 \\ 1 &0\end{matrix}\right]
$$

